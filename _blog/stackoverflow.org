
* Enumerating tags
http://stackoverflow.com/questions/24330980/enumerate-all-tags-in-org-mode/27517702#27517702

#+BEGIN_SRC emacs-lisp
(setq my-hash (make-hash-table :test 'equal))

(org-map-entries
 (lambda ()
   (let ((tag-string (car (last (org-heading-components))))
	 (current-count))
     (when tag-string	
       (dolist (tag (split-string tag-string ":" t))
	 
	 (setq current-count (gethash tag my-hash))
	 (message "tag: %s (%s)" tag current-count)
	 (if current-count;
	     (puthash tag (+ 1 current-count)  my-hash)
	   (puthash tag 1 my-hash))
	 )
       )
     )
   )
 )

;; https://github.com/Wilfred/ht.el
(require 'ht)
(ht-map
 (lambda (key value)
   (list key value))
 my-hash)
#+END_SRC

#+RESULTS:
| bar | 2 |
| foo | 3 |


Second approach.

#+BEGIN_SRC emacs-lisp :results raw
(defun get-tag-counts ()
  (let ((all-tags '()))
    (org-map-entries
     (lambda ()
       (let ((tag-string (car (last (org-heading-components)))))
	 (when tag-string	
	   (setq all-tags
		 (append all-tags (split-string tag-string ":" t)))))))
    
    
    ;; now get counts
    (loop for tag in (-uniq all-tags) 
	  collect (cons tag (cl-count tag all-tags :test 'string=)))))

(get-tag-counts)
#+END_SRC

#+RESULTS:
((foo . 3) (bar . 2) (presentation . 1))


** subhead1				 :foo:bar:
** subhead2				     :foo:
** subhead3				 :foo:bar:

* [[http://stackoverflow.com/questions/27304469/capturing-the-output-of-diff-with-org-babel][emacs - Capturing the output of "diff" with org-babel - Stack Overflow]]

#+BEGIN_SRC sh
echo "a b c" > f1
echo "a c b" > f2
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh
diff f1 f2
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(org-babel-eval "sh" "diff f1 f2")
#+END_SRC

(defun rb (start end)
 (interactive "r")
 (insert (format "%s %s" (region-beginning) (region-end))))

#+BEGIN_SRC emacs-lisp
(org-babel--shell-command-on-region
 336 346 "sh" (current-buffer))
#+END_SRC



* [[http://stackoverflow.com/questions/25895721/org-mode-include-heading/27262912?noredirect%3D1#comment43041161_27262912][emacs - Org Mode include heading - Stack Overflow]] take 2

Include content from some heading in another org-file

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "include"
 ;; follow
 (lambda (path)
   (let ((cb (current-buffer)))
     (org-open-link-from-string (concat "file:" path) "*t*)
     (message-box "%s" (buffer-file-name)))))
#+END_SRC

#+RESULTS:
| lambda | (path) | (let ((cb (current-buffer))) (org-open-link-from-string (concat file: path) (current-buffer)) (message-box %s (buffer-file-name))) |

include:my-table.org::*Regressions 

* [[http://stackoverflow.com/questions/25895721/org-mode-include-heading][emacs - Org Mode include heading - Stack Overflow]]

** Heading 1/Regressions	    :presentation:
#+INCLUDE: my-table.org :minlevel 2


* [[http://stackoverflow.com/questions/13228001/org-mode-nested-properties][emacs - Org-mode nested properties? - Stack Overflow]]


** subheading
   :PROPERTIES:
   :my-prop:  (:property-1 red :property-2 (nested-prop . 5))
   :END:


#+BEGIN_SRC emacs-lisp
(defun get-my-prop-value (property)
  (interactive)
  (plist-get
   (read (org-entry-get (point) "my-prop"))
   property))
#+END_SRC

#+RESULTS:
: get-my-prop-value



#+BEGIN_SRC emacs-lisp
(get-my-prop-value :property-2)
#+END_SRC

#+RESULTS:
: (nested-prop . 5)


* test bib

some reference cite:armiento-2014-high


bibliography:~/Dropbox/bibliography/references.bib

1. add stuff label:stuff
2. Stir
3. Use ingredients from step ref:stuff to fill container.


1. add stuff
2. Stir <<stir-label>>
3. Use something from step [[stir-label]] to get there.
* [[http://stackoverflow.com/questions/2581935/import-csv-into-org-mode-properties?rq%3D1][emacs - Import CSV into Org-mode properties - Stack Overflow]]
  :PROPERTIES:
  :Name:     John
  :Tel:      11111
  :Mobile:   22222
  :Fax:      33333
  :END:

#+BEGIN_SRC text :tangle data.csv
Name,Tel,Mobile,Fax
John,11111,22222,33333
#+END_SRC


#+BEGIN_SRC emacs-lisp
(let ((lines (with-temp-buffer 
	       (insert-file-contents "data.csv")
	       (split-string (buffer-string) "\n")))
      (properties)
      (values))

  (setq properties (split-string (car lines) ","))

  (loop for line in (cdr lines)
	do  
	(setq values (split-string line ","))
	(loop for property in properties
	      for value in values
	      do 
	      (org-entry-put (point) property value))))
#+END_SRC

#+RESULTS:


* https://emacs.stackexchange.com/questions/30729/is-it-possible-to-define-all-keywords-function-definitions-as-plist-get

This is a new way to use closures.

#+BEGIN_SRC emacs-lisp :lexical t :results raw
(let ((data '(:keyword "value" :keyword2 'value2)))
  (defalias 'd
    (lambda (key)
      (plist-get data key))))

(d :keyword2)
#+END_SRC

#+RESULTS:
(quote value2)
