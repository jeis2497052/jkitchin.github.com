* DONE Adding numerical methods to emacs with dynamic modules
  CLOSED: [2017-07-08 Sat 10:13]
  :PROPERTIES:
  :categories: emacs
  :date:     2017/07/08 10:12:45
  :updated:  2017/07/09 07:31:12
  :org-url:  http://kitchingroup.cheme.cmu.edu/org/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules.org
  :permalink: http://kitchingroup.cheme.cmu.edu/blog/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules/index.html
  :END:

There is a relatively new feature in Emacs 25 that allows you to extend Emacs using compiled libraries (http://diobla.info/blog-archive/modules-tut.html). This could be very helpful in a few ways:

1. To add functionality that exists in other libraries, e.g.
   1. [[https://github.com/syohex/emacs-libyaml][libyaml]]
   2. [[https://github.com/syohex/emacs-memcached][libmemcached]]
   3. [[https://github.com/syohex/emacs-mruby-test][Embedding Ruby in Emacs]]
2. Interface Emacs with hardware, e.g. [[http://nullprogram.com/blog/2016/11/05/][a joystick]], or [[https://github.com/syohex/emacs-eject][ejecting a CD]].
3. To speed up slow elisp functions
   1. A c implementation of a fibonacci function is 150 times faster than an elisp version [[https://coldnew.github.io/2d16cc25/][here]].
   2. This [[https://github.com/syohex/emacs-parson][json parser]] is up to 4 times faster than the json.el library for some operations.

I am interested in this in particular to bring numerical methods into Emacs. It is fair to ask why. Even I think the numpy/scipy/matplotlib Python stack is currently unparalleled in functionality for scientific programming. But I like writing elisp code so much more! So, we will take a look today at a simple example of integrating a function from the GNU Scientific Library into Emacs.

** Using the GSL to calculate a Bessel function value

A canonical example of using the GSL is given at https://www.gnu.org/software/gsl/manual/html_node/An-Example-Program.html. Here it is for reference. It just calculates a value for a Bessel function. We save this program in a file called example.c.

#+BEGIN_SRC C :tangle example.c
#include <stdio.h>
#include <gsl/gsl_sf_bessel.h>

int
main (void)
{
  double x = 5.0;
  double y = gsl_sf_bessel_J0 (x);
  printf ("J0(%g) = %.18e\n", x, y);
  return 0;
}
#+END_SRC

We have to compile and run this program. Here are the commands to do that.

#+BEGIN_SRC sh
gcc -Wall -I/usr/local/include/ -c example.c
gcc -L/usr/local/include -lgsl example.o 
./a.out
#+END_SRC

#+RESULTS:
: J0(5) = -1.775967713143382642e-01

That is a lot of code and steps to get one number. 

What I would like to do instead is this:

#+BEGIN_SRC emacs-lisp
(require 'gsl-sf-bessel)
(gsl-sf-bessel-J0 5)
#+END_SRC

So, enter the dynamic module!

** A GSL dynamic module for a Bessel function

To create the dynamic module we need a small c file that wraps the GSL function and adds it to the Emacs environment. Here is the smallest example I could come up with for this one function.  Basically, we create a function that takes the emacs environment and arguments, extract what we want from them, and use that to calculate what we need and return it to the environment. Then we register that function  and define what the module provides in emacs_module_init.

#+BEGIN_SRC c :tangle gsl-sf-bessel.c
#include <assert.h>
#include <gsl/gsl_sf_bessel.h>
#include "emacs-module.h"

int plugin_is_GPL_compatible;

static emacs_value
F_gsl_sf_bessel_J0 (emacs_env *env, ptrdiff_t nargs, emacs_value args[], void *data)
{
  assert (nargs == 1);
  double x = env->extract_float (env, args[0]);
  return env->make_float (env, gsl_sf_bessel_J0 (x));
}

int
emacs_module_init(struct emacs_runtime *ert)
{
	emacs_env *env = ert->get_environment(ert);

	emacs_value gsl_sf_bessel_J0_fn = env->make_function(env, 1, 1, F_gsl_sf_bessel_J0, "Regular cylindrical Bessel function of zeroth order, J_0(x)", NULL);

	emacs_value Qfset = env->intern(env, "fset");
	emacs_value Q_gsl_sf_bessel_J0 = env->intern(env, "gsl-sf-bessel-J0");
	emacs_value fset_args[] = { Q_gsl_sf_bessel_J0, gsl_sf_bessel_J0_fn };
	env->funcall(env, Qfset, 2, fset_args);

	emacs_value Qprovide = env->intern(env, "provide");
	emacs_value Q_gsl_sf_bessel = env->intern(env, "gsl-sf-bessel");
	emacs_value provide_args[] = { Q_gsl_sf_bessel };
	env->funcall(env, Qprovide, 1, provide_args);

	return 0;
}
#+END_SRC

Now we compile it into a shared library.

#+BEGIN_SRC sh
gcc -Wall -I/usr/local/include -fPIC -c gsl-sf-bessel.c
gcc -shared -L/usr/local/include -lgsl -o gsl-sf-bessel.so gsl-sf-bessel.o
#+END_SRC

#+RESULTS:

That creates our shared library in gsl-sf-bessel.so.

#+BEGIN_SRC sh
ls *.so
#+END_SRC

#+RESULTS:
: gsl-sf-bessel.so

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/")
(require 'gsl-sf-bessel)
(gsl-sf-bessel-J0 5.0)
#+END_SRC

#+RESULTS:
: -0.17759677131433826

That is the same answer as we got before. Here is the documentation we defined. It could use some improvement, e.g. to note that the argument has to be a float, and that only one argument is allowed. I am not sure why the signature doesn't show a single argument.

#+BEGIN_SRC emacs-lisp
(describe-function 'gsl-sf-bessel-J0)
#+END_SRC

#+RESULTS:
: gsl-sf-bessel-J0 is a Lisp function.
: 
: (gsl-sf-bessel-J0 &rest ARGS)
: 
: For more information check the manuals.
: 
: Regular cylindrical Bessel function of zeroth order, J_0(x)

I am not a very skilled C-programmer yet, so I don't know how hard it would be to make this function accept integers as well, or to vectorize it so you could have an arbitrary number of args to it and return a list.


** Summary

Dynamic modules look promising to extend Emacs with. This example is about the simplest function from the GSL there is. There are many more (https://www.gnu.org/software/gsl/doc/html/index.html) functions that do linear algebra on arrays, integration or optimization of functions, interpolation of data, etc. I don't have a sense yet of how easy it will be to integrate these into a module.

It looks like you are not limited to writing these in C. There is an example of a plugin written in Rust [[https://github.com/lunaryorn/emacs-module.rs/blob/master/src/lib.rs][here]], and a framework to write them in [[https://github.com/sigma/go-emacs/][Go]]. Maybe any language that can make a shared library with the required plugin_is_GPL_compatible symbol and emacs_module_init function would work. Those examples do not look significantly easier to write than the C versions though since I am not that fluent in those languages either.

There are some challenges to figure out in developing and using dynamic modules. Here are a few:

1. The documentation on what is possible is not that great yet, so there is a lot of exploring to do. There are a fair number of examples out there though to learn from (https://github.com/emacs-pe/emacs-modules). The [[https://github.com/emacs-mirror/emacs/tree/emacs-25/modules/mod-test][official example]] shows a lot of the functionality.
2. I guess it will be tricky to distribute these. I don't know how easy it would be to build all the libraries for each platform for distribution on MELPA for example. I don't think there is a standard way to incorporate a compile step in elisp package installation. Also, you need an Emacs version of at least 25 with the dynamic module feature compiled in. It is not yet a default enabled option. The required emacs-module.h should be gotten from the emacs build, so people with binaries might not be able to build it anyway.
3. Users will need the libraries the dynamic module uses. In this example, they will need libgsl.
4. Once you require the module, it does not seem possible to modify it, rebuild it, and reload it. It appears you have to close Emacs and reload it. That is tedious.

It would be nice to have a more generic foreign function interface that would allow you to develop more on the elisp side. One effort in that direction is https://github.com/tromey/emacs-ffi. It looks like it might be a lot simpler to use than creating a dynamic module. Once it is installed, it looks like you can write elisp code to wrap the library functions. I will write about this on another day.




* DONE Adding a GSL integration function to Emacs with a dynamic module
  CLOSED: [2017-07-09 Sun 07:22]
  :PROPERTIES:
  :categories: emacs,integration,dynamic-module
  :date:     2017/07/09 07:22:01
  :updated:  2017/07/09 07:30:20
  :org-url:  http://kitchingroup.cheme.cmu.edu/org/2017/07/09/Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module.org
  :permalink: http://kitchingroup.cheme.cmu.edu/blog/2017/07/09/Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module/index.html
  :END:

Here we work out how to run this program: https://www.gnu.org/software/gsl/doc/html/integration.html#adaptive-integration-example in a dynamic module in emacs. The goal is to be able to evaluate $\int_0^1 x^{1/2} \log(x) dx$. According to the example page the answer is -4. We will define an integration function that takes at least a function and integration bounds as arguments, and several optional arguments to specify tolerances and limits. In other words we want to evaluate integrals of the form:

$\int_a^b f(x; params) dx$

I want that to happen in an elisp function with a signature like:

#+BEGIN_SRC emacs-lisp
(gsl-integration-qags (lambda (x params) body) a b &optional params epsabs epsrel limit)
#+END_SRC

And that function will return a list containing (result error-estimate). Here is the C-code that makes this happen. It is more complex that the [[http://kitchingroup.cheme.cmu.edu/blog/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules/][last example]], and only compiles with gcc that allows nested functions. I don't know how to write this without that feature. This is more complex also because you have to create a workspace to do the integration inside the function that does the integration. The C-module also has extra code in it to allow for optional arguments.

#+BEGIN_SRC c :tangle gsl-integration.c
#include <gsl/gsl_integration.h>
#include "emacs-module.h"

int plugin_is_GPL_compatible;

static emacs_value F_gsl_integrate (emacs_env *env, ptrdiff_t nargs, emacs_value args[], void *data)
{
  // nested function - only supported as an extension in gcc
  double f (double x, void *params) 
  {
    emacs_value fn = args[0];  // function we will integrate
    emacs_value x2[] = { env->make_float(env, x), params };
    emacs_value y = env->funcall(env, fn, 2, &x2);   
    
    return env->extract_float (env, y);
  }

  double a = env->extract_float (env, args[1]);
  double b = env->extract_float (env, args[2]);

  // default values for optional arguments
  double epsabs = 0.0;
  double epsrel = 1e-7;
  size_t limit = 1000;
  double result, error; 

  // Here is how I handle the optional arguments
  // (gsl-integrate func a b params epsabs epsrel limit)
  gsl_function F;
  F.function = &f;
  if (nargs >= 4) {F.params = args[3];}
  if (nargs >= 5 && env->is_not_nil(env, args[4])) {epsabs = env->extract_float(env, args[4]);}
  if (nargs >= 6 && env->is_not_nil(env, args[5])) {epsrel = env->extract_float(env, args[5]);}
  if (nargs >= 7 && env->is_not_nil(env, args[6])) {limit = env->extract_integer(env, args[6]);}

  gsl_integration_workspace * w = gsl_integration_workspace_alloc (limit);

  gsl_integration_qags (&F, // gsl_function pointer
			a, // lower integration bound
			b, // upper integration bound
			epsabs, // absolute error tolerance
			epsrel, // relative error tolerance
			limit, // max number of subintervals for integration
                        w, // the workspace
			// pointers to put results and error in
			&result, &error);

  gsl_integration_workspace_free (w);
    
  // make a list of (result error) to return
  emacs_value Qlist = env->intern(env, "list");
  emacs_value Qresult = env->make_float (env, result);
  emacs_value Qerror = env->make_float (env, error);
  emacs_value list_args[] = { Qresult, Qerror };
  return env->funcall(env, Qlist, 2, list_args);
}

int emacs_module_init(struct emacs_runtime *ert)
{
  emacs_env *env = ert->get_environment(ert);
  
  // Here we create the function.
  emacs_value fset = env->intern(env, "fset");
  emacs_value args[2];
  args[0] = env->intern(env, "gsl-integration-qags"); // symbol to create for function
  // The function we set that symbol to.
  args[1] = env->make_function(env,
			       3, // min nargs
			       7, // max nargs
			       F_gsl_integrate,
			       "(gsl-integration-qags F A B &optional PARAMS EPSABS EPSREL LIMIT)\n" \
			       "Integrate F(x; params) from A to B.\n" \
			       "F is a function of a single variable and parameters.\n" \
			       "A is the lower bound of integration\n"	\
			       "B is the upper bound of integration.\n" \
			       "Optional parameters:\n"\
			       "PARAMS is a list of params to pass to F.\n" \
			       "EPSABS is a float (default 0.0) and is the absolute error tolerance.\n" \
			       "EPSREL is a float (default 1e-7) and is the relative error tolerance.\n" \
			       "LIMIT is the maximum number of subintervals for the integration (default 1000).\n" \
			       "Returns (list result error-estimate).\n" \
			       "See https://www.gnu.org/software/gsl/manual/html_node/QAGS-adaptive-integration-with-singularities.html.",
			       0);
  // This is basically (fset 'gsl-integration-qags (lambda func))
  env->funcall(env, fset, 2, args);
  
  // This is what allows the shared library to provide a feature 
  emacs_value provide = env->intern(env, "provide");
  emacs_value provide_args[] = { env->intern(env, "gsl-integration") };
  env->funcall(env, provide, 1, provide_args);
  
  return 0;
}
#+END_SRC

Building this was moderately tricky. It appears the first gcc on my path uses clang which does not support nested functions in C. I don't know enough C to figure out how to do this without a nested function though, since the function has to be defined at run-time based on the emacs env and args. gcc does support inline functions, so the code below uses a gcc that does compile it.

#+BEGIN_SRC sh
rm -f gsl-integration.so gsl-integration.o
/usr/local/Cellar/gcc/6.1.0/bin/gcc-6 -Wall -I/usr/local/include -fPIC -c gsl-integration.c
/usr/local/Cellar/gcc/6.1.0/bin/gcc-6  -shared -L/usr/local/include -lgsl -o gsl-integration.so gsl-integration.o
#+END_SRC

#+RESULTS:

Now we add this directory to our path since it is not on it and require our new module.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/")
(require 'gsl-integration)
#+END_SRC

#+RESULTS:
: gsl-integration

Let us see our new function in action. We evaluate $\int_0^1 x^{1/2} \log(x) dx$. According to the example page the answer is -4. Here is an example where we ignore the parameters. You have to be careful; Emacs sometimes segfaults and crashes if you use an integer or float argument when it expects the other type.

#+BEGIN_SRC emacs-lisp
(gsl-integration-qags (lambda (x params) (/ (log x) (sqrt x))) 0.0 1.0)
#+END_SRC

#+RESULTS:
| -4.000000000000085 | 1.354472090042691e-13 |

Here are some optional arguments. 

#+BEGIN_SRC emacs-lisp 
(gsl-integration-qags (lambda (x params) (/ (log x) (sqrt x))) 0.0 1.0 nil nil 0.01)
#+END_SRC

#+RESULTS:
| -4.000000000000075 | 0.019526557540360034 |

Nice, with a larger epsrel argument we get a larger error. Note the arguments are positional, so we have to include them all just to set the epsrel argument. How about an easier example with parameters that we actually use. Here we integrate a constant, and set the value of the constant from the params arg. The integral should be the area of a rectangle of length 1 and width of the param we use.

#+BEGIN_SRC emacs-lisp 
(list
 (gsl-integration-qags (lambda (x params) (first params)) 0.0 1.0 '(1.0))
 (gsl-integration-qags (lambda (x params) (first params)) 0.0 1.0 '(0.5)))
#+END_SRC

#+RESULTS:
| 1.0 | 1.1102230246251565e-14 |
| 0.5 |  5.551115123125783e-15 |

Wow! It actually works!!! That was harder won success than usual for me. I am claiming victory for now and leaving the following notes to future me:

1. It would be nice to have optional keyword arguments. This would take some handling of the arguments beyond what I know how to do for now, unless it is possible to pull in something like plist-get the way we pull in fset, provide and list in this example.
2. Error checking on types would be helpful. It is not good for Emacs to crash because 0 is not 0.0!
3. In numpy there is often a feature to get full_output. Here, the workspace created in the function has more information available in a struct that might be helpful to have access to at times. It seems like it might be possible to get that here too.

* A GSL root finder in a dynamic module

In a previous [[http://kitchingroup.cheme.cmu.edu/blog/2017/05/21/A-partial-symbolic-numeric-solver-in-emacs-lisp/][post]] I implemented a Newton solver in elisp to solve some problems numerically. Today, we continue the dynamic module studies and implement a bracketed root solver from the GNU Scientific Library (https://www.gnu.org/software/gsl/doc/html/roots.html#examples).

#+BEGIN_SRC emacs-lisp
(gsl-root-fsolver-brent f xlo xhi params epsabs epsrel)
#+END_SRC

#+BEGIN_SRC c :tangle gsl-roots.c
#include <gsl/gsl_errno.h>
#include <gsl/gsl_roots.h>
#include "emacs-module.h"

int plugin_is_GPL_compatible;

static emacs_value Fgsl_root_fsolver_brent (emacs_env *env, ptrdiff_t nargs, emacs_value args[], void *data)
{

// nested function - only supported as an extension in gcc
  double f (double x, void *params) 
  {
    emacs_value fn = args[0];  // function we will integrate
    emacs_value x2[] = { env->make_float(env, x), params };
    emacs_value y = env->funcall(env, fn, 2, &x2);   
    
    return env->extract_float (env, y);
  }

  int status;
  int iter = 0, max_iter = 100;
  const gsl_root_fsolver_type *T;
  gsl_root_fsolver *s;
  double result = 0;

  double x_lo = env->extract_float (env, args[1]);
  double x_hi = env->extract_float (env, args[2]);

 gsl_function F;

  F.function = &f;
  if (nargs >= 4) {F.params = args[3];}

  // default values for optional arguments
  double epsabs = 0.0;
  double epsrel = 0.001;

  if (nargs >= 5 && env->is_not_nil(env, args[4])) {epsabs = env->extract_float(env, args[4]);}
  if (nargs >= 6 && env->is_not_nil(env, args[5])) {epsrel = env->extract_float(env, args[5]);}
  
  T = gsl_root_fsolver_brent;
  s = gsl_root_fsolver_alloc (T);
  gsl_root_fsolver_set (s, &F, x_lo, x_hi);

  do
    {
      iter++;
      status = gsl_root_fsolver_iterate (s);
      result = gsl_root_fsolver_root (s);
      x_lo = gsl_root_fsolver_x_lower (s);
      x_hi = gsl_root_fsolver_x_upper (s);
      status = gsl_root_test_interval (x_lo, x_hi,
                                       epsabs, epsrel);

    }
  while (status == GSL_CONTINUE && iter < max_iter);

  gsl_root_fsolver_free (s);

  return env->make_float (env, result);
}


int emacs_module_init(struct emacs_runtime *ert)
{
  emacs_env *env = ert->get_environment(ert);
  
  // Here we create the function.
  emacs_value fset = env->intern(env, "fset");
  emacs_value args[2];
  args[0] = env->intern(env, "gsl-root-fsolver-brent"); // symbol to create for function
  // The function we set that symbol to.
  args[1] = env->make_function(env,
			       3, // min nargs
			       7, // max nargs
			       Fgsl_root_fsolver_brent,
			       "(gsl-root-fsolver-brent f xlo xhi params &optional epsabs epsrel)\n" 
			       "https://www.gnu.org/software/gsl/doc/html/roots.html#examples",
			       0);

  env->funcall(env, fset, 2, args);
  
  // This is what allows the shared library to provide a feature 
  emacs_value provide = env->intern(env, "provide");
  emacs_value provide_args[] = { env->intern(env, "gsl-roots") };
  env->funcall(env, provide, 1, provide_args);
  
  return 0;
}
#+END_SRC


#+BEGIN_SRC sh
rm -f gsl-roots.so gsl-roots.o
/usr/local/Cellar/gcc/6.1.0/bin/gcc-6 -Wall -I/usr/local/include -fPIC -c gsl-roots.c
/usr/local/Cellar/gcc/6.1.0/bin/gcc-6  -shared -L/usr/local/include -lgsl -o gsl-roots.so gsl-roots.o
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(require 'gsl-roots)
#+END_SRC

#+RESULTS:
: gsl-roots

#+BEGIN_SRC emacs-lisp
(gsl-root-fsolver-brent (lambda (x params) (- (* x x) 5)) 0.0 5.0)
#+END_SRC

#+RESULTS:
: 2.2360634081902244

awesome sauce!

