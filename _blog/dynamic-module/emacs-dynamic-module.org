* DONE Adding numerical methods to emacs with dynamic modules
  CLOSED: [2017-07-08 Sat 10:13]
  :PROPERTIES:
  :categories: emacs
  :date:     2017/07/08 10:12:45
  :updated:  2017/07/09 07:31:12
  :org-url:  http://kitchingroup.cheme.cmu.edu/org/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules.org
  :permalink: http://kitchingroup.cheme.cmu.edu/blog/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules/index.html
  :END:

There is a relatively new feature in Emacs 25 that allows you to extend Emacs using compiled libraries (http://diobla.info/blog-archive/modules-tut.html). This could be very helpful in a few ways:

1. To add functionality that exists in other libraries, e.g.
   1. [[https://github.com/syohex/emacs-libyaml][libyaml]]
   2. [[https://github.com/syohex/emacs-memcached][libmemcached]]
   3. [[https://github.com/syohex/emacs-mruby-test][Embedding Ruby in Emacs]]
2. Interface Emacs with hardware, e.g. [[http://nullprogram.com/blog/2016/11/05/][a joystick]], or [[https://github.com/syohex/emacs-eject][ejecting a CD]].
3. To speed up slow elisp functions
   1. A c implementation of a fibonacci function is 150 times faster than an elisp version [[https://coldnew.github.io/2d16cc25/][here]].
   2. This [[https://github.com/syohex/emacs-parson][json parser]] is up to 4 times faster than the json.el library for some operations.

I am interested in this in particular to bring numerical methods into Emacs. It is fair to ask why. Even I think the numpy/scipy/matplotlib Python stack is currently unparalleled in functionality for scientific programming. But I like writing elisp code so much more! So, we will take a look today at a simple example of integrating a function from the GNU Scientific Library into Emacs.

** Using the GSL to calculate a Bessel function value

A canonical example of using the GSL is given at https://www.gnu.org/software/gsl/manual/html_node/An-Example-Program.html. Here it is for reference. It just calculates a value for a Bessel function. We save this program in a file called example.c.

#+BEGIN_SRC C :tangle example.c
#include <stdio.h>
#include <gsl/gsl_sf_bessel.h>

int
main (void)
{
  double x = 5.0;
  double y = gsl_sf_bessel_J0 (x);
  printf ("J0(%g) = %.18e\n", x, y);
  return 0;
}
#+END_SRC

We have to compile and run this program. Here are the commands to do that.

#+BEGIN_SRC sh
gcc -Wall -I/usr/local/include/ -c example.c
gcc -L/usr/local/include -lgsl example.o 
./a.out
#+END_SRC

#+RESULTS:
: J0(5) = -1.775967713143382642e-01

That is a lot of code and steps to get one number. 

What I would like to do instead is this:

#+BEGIN_SRC emacs-lisp
(require 'gsl-sf-bessel)
(gsl-sf-bessel-J0 5)
#+END_SRC

So, enter the dynamic module!

** A GSL dynamic module for a Bessel function

To create the dynamic module we need a small c file that wraps the GSL function and adds it to the Emacs environment. Here is the smallest example I could come up with for this one function.  Basically, we create a function that takes the emacs environment and arguments, extract what we want from them, and use that to calculate what we need and return it to the environment. Then we register that function  and define what the module provides in emacs_module_init.

#+BEGIN_SRC c :tangle gsl-sf-bessel.c
#include <assert.h>
#include <gsl/gsl_sf_bessel.h>
#include "emacs-module.h"

int plugin_is_GPL_compatible;

static emacs_value
F_gsl_sf_bessel_J0 (emacs_env *env, ptrdiff_t nargs, emacs_value args[], void *data)
{
  assert (nargs == 1);
  double x = env->extract_float (env, args[0]);
  return env->make_float (env, gsl_sf_bessel_J0 (x));
}

int
emacs_module_init(struct emacs_runtime *ert)
{
	emacs_env *env = ert->get_environment(ert);

	emacs_value gsl_sf_bessel_J0_fn = env->make_function(env, 1, 1, F_gsl_sf_bessel_J0, "Regular cylindrical Bessel function of zeroth order, J_0(x)", NULL);

	emacs_value Qfset = env->intern(env, "fset");
	emacs_value Q_gsl_sf_bessel_J0 = env->intern(env, "gsl-sf-bessel-J0");
	emacs_value fset_args[] = { Q_gsl_sf_bessel_J0, gsl_sf_bessel_J0_fn };
	env->funcall(env, Qfset, 2, fset_args);

	emacs_value Qprovide = env->intern(env, "provide");
	emacs_value Q_gsl_sf_bessel = env->intern(env, "gsl-sf-bessel");
	emacs_value provide_args[] = { Q_gsl_sf_bessel };
	env->funcall(env, Qprovide, 1, provide_args);

	return 0;
}
#+END_SRC

Now we compile it into a shared library.

#+BEGIN_SRC sh
gcc -Wall -I/usr/local/include -fPIC -c gsl-sf-bessel.c
gcc -shared -L/usr/local/include -lgsl -o gsl-sf-bessel.so gsl-sf-bessel.o
#+END_SRC

#+RESULTS:

That creates our shared library in gsl-sf-bessel.so.

#+BEGIN_SRC sh
ls *.so
#+END_SRC

#+RESULTS:
: gsl-sf-bessel.so

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/")
(require 'gsl-sf-bessel)
(gsl-sf-bessel-J0 5.0)
#+END_SRC

#+RESULTS:
: -0.17759677131433826

That is the same answer as we got before. Here is the documentation we defined. It could use some improvement, e.g. to note that the argument has to be a float, and that only one argument is allowed. I am not sure why the signature doesn't show a single argument.

#+BEGIN_SRC emacs-lisp
(describe-function 'gsl-sf-bessel-J0)
#+END_SRC

#+RESULTS:
: gsl-sf-bessel-J0 is a Lisp function.
: 
: (gsl-sf-bessel-J0 &rest ARGS)
: 
: For more information check the manuals.
: 
: Regular cylindrical Bessel function of zeroth order, J_0(x)

I am not a very skilled C-programmer yet, so I don't know how hard it would be to make this function accept integers as well, or to vectorize it so you could have an arbitrary number of args to it and return a list.


** Summary

Dynamic modules look promising to extend Emacs with. This example is about the simplest function from the GSL there is. There are many more (https://www.gnu.org/software/gsl/doc/html/index.html) functions that do linear algebra on arrays, integration or optimization of functions, interpolation of data, etc. I don't have a sense yet of how easy it will be to integrate these into a module.

It looks like you are not limited to writing these in C. There is an example of a plugin written in Rust [[https://github.com/lunaryorn/emacs-module.rs/blob/master/src/lib.rs][here]], and a framework to write them in [[https://github.com/sigma/go-emacs/][Go]]. Maybe any language that can make a shared library with the required plugin_is_GPL_compatible symbol and emacs_module_init function would work. Those examples do not look significantly easier to write than the C versions though since I am not that fluent in those languages either.

There are some challenges to figure out in developing and using dynamic modules. Here are a few:

1. The documentation on what is possible is not that great yet, so there is a lot of exploring to do. There are a fair number of examples out there though to learn from (https://github.com/emacs-pe/emacs-modules). The [[https://github.com/emacs-mirror/emacs/tree/emacs-25/modules/mod-test][official example]] shows a lot of the functionality.
2. I guess it will be tricky to distribute these. I don't know how easy it would be to build all the libraries for each platform for distribution on MELPA for example. I don't think there is a standard way to incorporate a compile step in elisp package installation. Also, you need an Emacs version of at least 25 with the dynamic module feature compiled in. It is not yet a default enabled option. The required emacs-module.h should be gotten from the emacs build, so people with binaries might not be able to build it anyway.
3. Users will need the libraries the dynamic module uses. In this example, they will need libgsl.
4. Once you require the module, it does not seem possible to modify it, rebuild it, and reload it. It appears you have to close Emacs and reload it. That is tedious.

It would be nice to have a more generic foreign function interface that would allow you to develop more on the elisp side. One effort in that direction is https://github.com/tromey/emacs-ffi. It looks like it might be a lot simpler to use than creating a dynamic module. Once it is installed, it looks like you can write elisp code to wrap the library functions. I will write about this on another day.




* DONE Adding a GSL integration function to Emacs with a dynamic module
  CLOSED: [2017-07-09 Sun 07:22]
  :PROPERTIES:
  :categories: emacs,integration,dynamic-module
  :date:     2017/07/09 07:22:01
  :updated:  2017/07/11 07:37:29
  :org-url:  http://kitchingroup.cheme.cmu.edu/org/2017/07/09/Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module.org
  :permalink: http://kitchingroup.cheme.cmu.edu/blog/2017/07/09/Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module/index.html
  :END:

Here we work out how to run this program: https://www.gnu.org/software/gsl/doc/html/integration.html#adaptive-integration-example in a dynamic module in emacs. The goal is to be able to evaluate $\int_0^1 x^{-1/2} \log(x) dx$. According to the example page the answer is -4. We will define an integration function that takes at least a function and integration bounds as arguments, and several optional arguments to specify tolerances and limits. In other words we want to evaluate integrals of the form:

$\int_a^b f(x; params) dx$

I want that to happen in an elisp function with a signature like:

#+BEGIN_SRC emacs-lisp
(gsl-integration-qags (lambda (x params) body) a b &optional params epsabs epsrel limit)
#+END_SRC

And that function will return a list containing (result error-estimate). Here is the C-code that makes this happen. It is more complex that the [[http://kitchingroup.cheme.cmu.edu/blog/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules/][last example]], and only compiles with gcc that allows nested functions. I don't know how to write this without that feature. This is more complex also because you have to create a workspace to do the integration inside the function that does the integration. The C-module also has extra code in it to allow for optional arguments.

#+BEGIN_SRC c :tangle gsl-integration.c
#include <gsl/gsl_integration.h>
#include "emacs-module.h"

int plugin_is_GPL_compatible;

static emacs_value F_gsl_integrate (emacs_env *env, ptrdiff_t nargs, emacs_value args[], void *data)
{
  // nested function - only supported as an extension in gcc
  double f (double x, void *params) 
  {
    emacs_value fn = args[0];  // function we will integrate
    emacs_value x2[] = { env->make_float(env, x), params };
    emacs_value y = env->funcall(env, fn, 2, &x2);   
    
    return env->extract_float (env, y);
  }

  double a = env->extract_float (env, args[1]);
  double b = env->extract_float (env, args[2]);

  // default values for optional arguments
  double epsabs = 0.0;
  double epsrel = 1e-7;
  size_t limit = 1000;
  double result, error; 

  // Here is how I handle the optional arguments
  // (gsl-integrate func a b params epsabs epsrel limit)
  gsl_function F;
  F.function = &f;
  if (nargs >= 4) {F.params = args[3];}
  if (nargs >= 5 && env->is_not_nil(env, args[4])) {epsabs = env->extract_float(env, args[4]);}
  if (nargs >= 6 && env->is_not_nil(env, args[5])) {epsrel = env->extract_float(env, args[5]);}
  if (nargs >= 7 && env->is_not_nil(env, args[6])) {limit = env->extract_integer(env, args[6]);}

  gsl_integration_workspace * w = gsl_integration_workspace_alloc (limit);

  gsl_integration_qags (&F, // gsl_function pointer
			a, // lower integration bound
			b, // upper integration bound
			epsabs, // absolute error tolerance
			epsrel, // relative error tolerance
			limit, // max number of subintervals for integration
                        w, // the workspace
			// pointers to put results and error in
			&result, &error);

  gsl_integration_workspace_free (w);
    
  // make a list of (result error) to return
  emacs_value Qlist = env->intern(env, "list");
  emacs_value Qresult = env->make_float (env, result);
  emacs_value Qerror = env->make_float (env, error);
  emacs_value list_args[] = { Qresult, Qerror };
  return env->funcall(env, Qlist, 2, list_args);
}

int emacs_module_init(struct emacs_runtime *ert)
{
  emacs_env *env = ert->get_environment(ert);
  
  // Here we create the function.
  emacs_value fset = env->intern(env, "fset");
  emacs_value args[2];
  args[0] = env->intern(env, "gsl-integration-qags"); // symbol to create for function
  // The function we set that symbol to.
  args[1] = env->make_function(env,
			       3, // min nargs
			       7, // max nargs
			       F_gsl_integrate,
			       "(gsl-integration-qags F A B &optional PARAMS EPSABS EPSREL LIMIT)\n" \
			       "Integrate F(x; params) from A to B.\n" \
			       "F is a function of a single variable and parameters.\n" \
			       "A is the lower bound of integration\n"	\
			       "B is the upper bound of integration.\n" \
			       "Optional parameters:\n"\
			       "PARAMS is a list of params to pass to F.\n" \
			       "EPSABS is a float (default 0.0) and is the absolute error tolerance.\n" \
			       "EPSREL is a float (default 1e-7) and is the relative error tolerance.\n" \
			       "LIMIT is the maximum number of subintervals for the integration (default 1000).\n" \
			       "Returns (list result error-estimate).\n" \
			       "See https://www.gnu.org/software/gsl/manual/html_node/QAGS-adaptive-integration-with-singularities.html.",
			       0);
  // This is basically (fset 'gsl-integration-qags (lambda func))
  env->funcall(env, fset, 2, args);
  
  // This is what allows the shared library to provide a feature 
  emacs_value provide = env->intern(env, "provide");
  emacs_value provide_args[] = { env->intern(env, "gsl-integration") };
  env->funcall(env, provide, 1, provide_args);
  
  return 0;
}
#+END_SRC

Building this was moderately tricky. It appears the first gcc on my path uses clang which does not support nested functions in C. I don't know enough C to figure out how to do this without a nested function though, since the function has to be defined at run-time based on the emacs env and args. gcc does support inline functions, so the code below uses a gcc that does compile it.

#+BEGIN_SRC sh
rm -f gsl-integration.so gsl-integration.o
/usr/local/Cellar/gcc/6.1.0/bin/gcc-6 -Wall -I/usr/local/include -fPIC -c gsl-integration.c
/usr/local/Cellar/gcc/6.1.0/bin/gcc-6  -shared -L/usr/local/include -lgsl -o gsl-integration.so gsl-integration.o
#+END_SRC

#+RESULTS:

Now we add this directory to our path since it is not on it and require our new module.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/")
(require 'gsl-integration)
#+END_SRC

#+RESULTS:
: gsl-integration

Let us see our new function in action. We evaluate $\int_0^1 x^{-1/2} \log(x) dx$. According to the example page the answer is -4. Here is an example where we ignore the parameters. You have to be careful; Emacs sometimes segfaults and crashes if you use an integer or float argument when it expects the other type.

#+BEGIN_SRC emacs-lisp
(gsl-integration-qags (lambda (x params) (/ (log x) (sqrt x))) 0.0 1.0)
#+END_SRC

#+RESULTS:
| -4.000000000000085 | 1.354472090042691e-13 |

Here are some optional arguments. 

#+BEGIN_SRC emacs-lisp 
(gsl-integration-qags (lambda (x params) (/ (log x) (sqrt x))) 0.0 1.0 nil nil 0.01)
#+END_SRC

#+RESULTS:
| -4.000000000000075 | 0.019526557540360034 |

Nice, with a larger epsrel argument we get a larger error. Note the arguments are positional, so we have to include them all just to set the epsrel argument. How about an easier example with parameters that we actually use. Here we integrate a constant, and set the value of the constant from the params arg. The integral should be the area of a rectangle of length 1 and width of the param we use.

#+BEGIN_SRC emacs-lisp 
(list
 (gsl-integration-qags (lambda (x params) (first params)) 0.0 1.0 '(1.0))
 (gsl-integration-qags (lambda (x params) (first params)) 0.0 1.0 '(0.5)))
#+END_SRC

#+RESULTS:
| 1.0 | 1.1102230246251565e-14 |
| 0.5 |  5.551115123125783e-15 |

Wow! It actually works!!! That was harder won success than usual for me. I am claiming victory for now and leaving the following notes to future me:

1. It would be nice to have optional keyword arguments. This would take some handling of the arguments beyond what I know how to do for now, unless it is possible to pull in something like plist-get the way we pull in fset, provide and list in this example.
2. Error checking on types would be helpful. It is not good for Emacs to crash because 0 is not 0.0!
3. In numpy there is often a feature to get full_output. Here, the workspace created in the function has more information available in a struct that might be helpful to have access to at times. It seems like it might be possible to get that here too.



* DONE Adding GSL constants to Emacs in a dynamic module
  CLOSED: [2017-07-10 Mon 09:38]
  :PROPERTIES:
  :categories: emacs,dynamic-module
  :date:     2017/07/10 09:38:21
  :updated:  2017/07/10 09:38:21
  :org-url:  http://kitchingroup.cheme.cmu.edu/org/2017/07/10/Adding-GSL-constants-to-Emacs-in-a-dynamic-module.org
  :permalink: http://kitchingroup.cheme.cmu.edu/blog/2017/07/10/Adding-GSL-constants-to-Emacs-in-a-dynamic-module/index.html
  :END:

The GNU Scientific Library defines a lot of [[https://www.gnu.org/software/gsl/doc/html/const.html][physical constants]]. Since we are exploring how to make Emacs a more scientific environment to work in, it would be nice to import these constants to elisp. We do that through a dynamic module. This turned out to be tricky. I thought we could just use a funcall to defconst or defvar, but these are special forms and you cannot funcall them. @polizta on Stackoverflow [[https://emacs.stackexchange.com/questions/34049/how-do-you-define-constants-in-an-emacs-dynamic-module/34063#34063][pointed me to the path]] that led to success: You make a list like '(defconst sym val doc) and then eval it. That can be funcall'd, and it works nicely in the module below. It is a growing theme that it takes much hacking around to figure out how to do things like this.

The only other notable feature of this module is that I created a defconst function to make adding multiple constants less verbose. Here I only add two constants. There are about 408 constants defined in gsl_const_*.h, so brevity might be a good idea! Here is the module.

#+BEGIN_SRC c :tangle gsl-constants.c
#include <gsl/gsl_const_mksa.h>
#include "emacs-module.h"
#include "emacs-module-helpers.h"

int plugin_is_GPL_compatible;

int emacs_module_init(struct emacs_runtime *ert)
{
  emacs_env *env = ert->get_environment(ert);

  defconst(env, "GSL-CONST-MKSA-SPEED-OF-LIGHT",
	   GSL_CONST_MKSA_SPEED_OF_LIGHT,
	   "Speed of light in vacuum (m/s).");
  
  defconst(env, "GSL-CONST-MKSA-PLANCKS-CONSTANT-H",
	   GSL_CONST_MKSA_PLANCKS_CONSTANT_H,
	   "Plank's constant, h");

  provide(env, "gsl-constants");
  
  return 0;
}
#+END_SRC


Regular gcc will work to compile this module. 


#+BEGIN_SRC sh
rm -f gsl-constants.so gsl-constants.o emacs-module-helpers.o libemacs-module-helpers.so
gcc -Wall -I/usr/local/include -fPIC -c emacs-module-helpers.c 
gcc -shared -o libemacs-module-helpers.so emacs-module-helpers.o 

gcc -Wall -I/usr/local/include -fPIC -c gsl-constants.c
gcc -shared -L/usr/local/include -lgsl -L. -lemacs-module-helpers -o gsl-constants.so gsl-constants.o 
#+END_SRC

#+RESULTS:

Here is in action. 

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/")
(require 'gsl-constants)
GSL-CONST-MKSA-SPEED-OF-LIGHT
#+END_SRC

#+RESULTS:
: 299792458.0

We can see there is a docstring on that constant:

#+BEGIN_SRC emacs-lisp
(describe-variable 'GSL-CONST-MKSA-SPEED-OF-LIGHT)
#+END_SRC

#+RESULTS:
#+begin_example
GSL-CONST-MKSA-SPEED-OF-LIGHT's value is 299792458.0


  This variable can be risky when used as a file-local variable.

Documentation:
Speed of light in vacuum (m/s).

For more information check the manuals.

#+end_example


It is worth thinking about what we accomplished here. The value of each constant in GSL is stored in a header file. The units are stored in a comment next to the value, and the documentation is in an html page somewhere. It is not easy to introspect that! Getting it all into an Emacs variable makes that more introspectable, and findable. That means while typing elisp code you will get completion on these variables. Check this out:

#+BEGIN_SRC emacs-lisp
(apropos-variable "GSL-*")
(with-current-buffer "*Apropos*" (buffer-string))
#+END_SRC

#+RESULTS:
: Type RET on a type label to view its full documentation.
: 
: GSL-CONST-MKSA-PLANCKS-CONSTANT-H
:   Variable: Plank's constant, h
: GSL-CONST-MKSA-SPEED-OF-LIGHT
:   Variable: Speed of light in vacuum (m/s).

It seems like it might be possible to partially automate creation of this module by parsing the gsl_const*.h files. There is no automating adding the doc strings though, I am pretty sure that will have to be done by hand ;(




* Adding Linear algebra to Emacs with the GSL and dynamic modules
  :PROPERTIES:
  :categories: emacs,dynamic-module
  :END:

The goal is to be able to solve https://www.gnu.org/software/gsl/doc/html/linalg.html#examples:

\[\left(\begin{array}{cccc}
 0.18& 0.60& 0.57& 0.96 \\
 0.41& 0.24& 0.99& 0.58 \\
 0.14& 0.30& 0.97& 0.66 \\
 0.51& 0.13& 0.19& 0.85 \end{array} \right ) 
\left ( \begin{array}{c} x_0 \\ x_1 \\ x_2 \\ x_3 \end{array} \right )
= \left ( \begin{array}{c} 1.0 \\ 2.0 \\ 3.0 \\ 4.0 \end{array} \right ) \]

The answer is given as

\[x = \left ( \begin{array}{c} -4.05205 \\ -12.6056 \\ 1.66091 \\ 8.69377 \end{Array} \right ) \]

The syntax we want to use is:

#+BEGIN_SRC emacs-lisp
(let ((A [[0.18 0.60 0.57 0.96]
	  [0.41 0.24 0.99 0.58]
	  [0.14 0.30 0.97 0.66]
	  [0.51 0.13 0.19 0.85]])
      (b [1.0 2.0 3.0 4.0]))
  (gsl-linalg-LU-solve A b))
#+END_SRC

The module is written below. There are a few notable features. First, we have to loop over the inputs to create the arrays that GSL wants to solve this problem. I could not figure out a better way to do that than is shown below. Second, after the solution is obtained, we have to build up a vector to return. The solution is in a gsl_vector, and we need to create an array of emacs_value elements containing each element of the gsl_vector as a float, and then create a vector to return to emacs. I use vectors here because it was easy to get the size of the b vector, which is also related to the size of the A matrix.

#+BEGIN_SRC c :tangle gsl-linalg.c
#include "emacs-module.h"
#include <gsl/gsl_linalg.h>

int plugin_is_GPL_compatible;

static emacs_value Fgsl_linalg_LU_solve (emacs_env *env, ptrdiff_t nargs, emacs_value args[], void *data)
{
  // (solve A b) A and b are vectors  
  emacs_value A = args[0];
  emacs_value b = args[1];
  
  size_t n = env->vec_size(env, args[1]);
   
  double a_data[n][n];
  double b_data[n];

  emacs_value val;

  // copy data over to the arrays
  for (ptrdiff_t i = 0; i < n; i++)
    {
      val = env->vec_get(env, b, i);
      b_data[i] = env->extract_float(env, val);      
    }

  for (ptrdiff_t i = 0; i < n; i++)
    {
      emacs_value row = env->vec_get (env, A, i);
      for (ptrdiff_t j = 0; j < n; j++)
	{
	  val = env->vec_get(env, row, j);
	  a_data[i][j] = env->extract_float(env, val);
	}
    }
  
  gsl_matrix_view m = gsl_matrix_view_array (a_data, n, n);
  gsl_vector_view bb = gsl_vector_view_array (b_data, n);
  gsl_vector *x = gsl_vector_alloc (n);

  int s;

  gsl_permutation * p = gsl_permutation_alloc (n);
  gsl_linalg_LU_decomp (&m.matrix, p, &s);
  gsl_linalg_LU_solve (&m.matrix, p, &bb.vector, x);
 
  emacs_value *array = malloc(sizeof(emacs_value) * n);
  for (ptrdiff_t i = 0; i < n; i++)
    {
      array[i] = env->make_float(env, gsl_vector_get(x, i));      
    }
  
  emacs_value Fvector = env->intern(env, "vector");
  emacs_value vec = env->funcall(env, Fvector, n, array);
  free(array);
  return vec;
}

int emacs_module_init(struct emacs_runtime *ert)
{
  emacs_env *env = ert->get_environment(ert);
  
  // Here we create the function.
  emacs_value fset = env->intern(env, "fset");
  emacs_value args[2];
  args[0] = env->intern(env, "gsl-linalg-LU-solve"); // symbol to create for function
  // The function we set that symbol to.
  args[1] = env->make_function(env,
			       2, // min nargs
			       2, // max nargs
			       Fgsl_linalg_LU_solve,
			       "(gsl-linalg-LU-solve A b)." 			      ,
			       0);

  env->funcall(env, fset, 2, args);
  
  // This is what allows the shared library to provide a feature 
  emacs_value provide = env->intern(env, "provide");
  emacs_value provide_args[] = { env->intern(env, "gsl-linalg") };
  env->funcall(env, provide, 1, provide_args);
  
  return 0;
}
#+END_SRC

#+BEGIN_SRC sh
rm -f gsl-linalg.so gsl-linalg.o
/usr/local/Cellar/gcc/6.1.0/bin/gcc-6 -Wall -I/usr/local/include -fPIC -c gsl-linalg.c
/usr/local/Cellar/gcc/6.1.0/bin/gcc-6  -shared -L/usr/local/include -lgsl -o gsl-linalg.so gsl-linalg.o
#+END_SRC

#+RESULTS:


#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/")
(require 'gsl-linalg)
#+END_SRC

#+RESULTS:
: gsl-linalg

#+BEGIN_SRC emacs-lisp
(gsl-linalg-LU-solve
 [[0.18 0.60 0.57 0.96]
  [0.41 0.24 0.99 0.58]
  [0.14 0.30 0.97 0.66]
  [0.51 0.13 0.19 0.85]]
 [1.0 2.0 3.0 4.0])
#+END_SRC

#+RESULTS:
: [-4.052050229573973 -12.605611395906903 1.6609116267088417 8.693766928795227]

  double a_data[] = {
                      
                      
                      

  double b_data[] = { 

#+BEGIN_SRC emacs-lisp
[[0 0 0 0 0]
 [0 0 0 0 0]
 [0 0 0 42 0]
 [0 0 0 0 0]]
#+END_SRC

#+RESULTS:
: [[0 0 0 0 0] [0 0 0 0 0] [0 0 0 42 0] [0 0 0 0 0]]


* Improving dynamic module writing

- [[./emacs-module-helpers.h]] 
- [[./emacs-module-helpers.c]]

Build these files with this:

#+BEGIN_SRC sh
rm -f gsl-constants.so gsl-constants.o emacs-module-helpers.o libemacs-module-helpers.so
gcc -Wall -I/usr/local/include -fPIC -c emacs-module-helpers.c 
gcc -shared -o libemacs-module-helpers.so emacs-module-helpers.o 
#+END_SRC

#+RESULTS:

For modules put this at the top:

#+BEGIN_SRC c :tangle pretty.c
#include "emacs-module.h"
#include "emacs-module-helpers.h"

int plugin_is_GPL_compatible;

static emacs_value Ff4 (emacs_env *env, int nargs, emacs_value args[], void *data)
{
 emacs_value input = args[0];
 double N = env->extract_float(env, args[1]);

 int len = env->vec_size (env, input);

 emacs_value *array = malloc(sizeof(emacs_value) * len);

 // multiply each value by N
 for (ptrdiff_t i = 0; i < len; i++)
   {
     array[i] = env->make_float(env,
				N * env->extract_float(env,
						       env->vec_get (env, input, i)));
   }

 // If you change this to list, you get a list instead!
 emacs_value Fvector = env->intern(env, "vector");
 emacs_value vec = env->funcall(env, Fvector, len, array);
 free(array);
 return vec;
}

int emacs_module_init (struct emacs_runtime *ert)
{
  emacs_env *env = ert->get_environment (ert);

  DEFUN("g4", Ff4, 2, 2, "testdoc", NULL);

  provide (env, "pretty");

  /* loaded successfully */
  return 0;
}
#+END_SRC

Finally build the module like this.

#+BEGIN_SRC sh
rm -f gsl-constants.so gsl-constants.o emacs-module-helpers.o libemacs-module-helpers.so
gcc -Wall -I/usr/local/include -fPIC -c emacs-module-helpers.c 
gcc -shared -o libemacs-module-helpers.so emacs-module-helpers.o 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh
gcc -Wall -I/usr/local/include -fPIC -c pretty.c
gcc -shared -L. -lemacs-module-helpers -o pretty.so pretty.o 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/")
(require 'pretty)
#+END_SRC
