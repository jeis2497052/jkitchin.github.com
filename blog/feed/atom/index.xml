<?xml version="1.0" encoding="UTF-8"?>

<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
  >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2017-11-15T16:41:12Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Sensitivity analysis using automatic differentiation in Python]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2017/11/15/Sensitivity-analysis-using-automatic-differentiation-in-Python" />
    <id>http://jkitchin.github.io/blog/2017/11/15/Sensitivity-analysis-using-automatic-differentiation-in-Python</id>
    <updated>2017-11-15T08:41:05Z</updated>
    <published>2017-11-15T08:34:29Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="autograd" />
    <category scheme="http://jkitchin.github.io/blog" term="python" />
    <category scheme="http://jkitchin.github.io/blog" term="sensitivity" />
    <summary type="html"><![CDATA[Sensitivity analysis using automatic differentiation in Python]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2017/11/15/Sensitivity-analysis-using-automatic-differentiation-in-Python"><![CDATA[


&lt;p&gt;
This &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.428.6699&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;paper&lt;/a&gt; describes how sensitivity analysis requires access to the derivatives of a function. Say, for example we have a function describing the time evolution of the concentration of species A:
&lt;/p&gt;

&lt;p&gt;
\([A] = \frac{[A]_0}{k_1 + k_{-1}} (k_1 e^{(-(k_1 _ k_{-1})t)} + k_{-1})\)
&lt;/p&gt;

&lt;p&gt;
The local sensitivity of the concentration of A to the parameters \(k1\) and \(k_1\) are defined as \(\frac{\partial A}{\partial k1}\) and \(\frac{\partial A}{\partial k_1}\). Our goal is to plot the sensitivity as a function of time. We could derive those derivatives, but we will use auto-differentiation instead through the autograd package. Here we import numpy from the autograd package and plot the function above.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org5d5b53b"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; autograd.numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np

&lt;span style="color: #BA36A5;"&gt;A0&lt;/span&gt; = 1.0

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;A&lt;/span&gt;(t, k1, k_1):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; A0 / (k1 + k_1) * (k1 * np.exp(-(k1 + k_1) * t) + k_1)

%matplotlib inline
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #BA36A5;"&gt;t&lt;/span&gt; = np.linspace(0, 0.5)

&lt;span style="color: #BA36A5;"&gt;k1&lt;/span&gt; = 3.0
&lt;span style="color: #BA36A5;"&gt;k_1&lt;/span&gt; = 3.0
plt.plot(t, A(t, k1, k_1))
plt.xlim([0, 0.5])
plt.ylim([0, 1])
plt.xlabel(&lt;span style="color: #008000;"&gt;'t'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'A'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;img src="/media/ob-ipython-09dd39779fdcdb6e3f00397800ec05e6.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
The figure above reproduces Fig. 1 from the paper referenced above.  Next, we use autograd to get the derivatives. This is subtly different than our previous &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/11/14/Forces-by-automatic-differentiation-in-molecular-simulation/"&gt;post&lt;/a&gt;. First, we need the derivative of the function with respect to the second and third arguments; the default is the first argument. Second, we want to evaluate this derivative at each time value. We use the jacobian function in autograd to get these. This is different than grad, which will sum up the derivatives at each time. That might be useful for regression, but not for sensitivity analysis. Finally, to reproduce Figure 2a, we plot the absolute value of the sensitivities.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org194abad"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; jacobian

&lt;span style="color: #BA36A5;"&gt;dAdk1&lt;/span&gt; = jacobian(A, 1)
&lt;span style="color: #BA36A5;"&gt;dAdk_1&lt;/span&gt; = jacobian(A, 2)

plt.plot(t, np.&lt;span style="color: #006FE0;"&gt;abs&lt;/span&gt;(dAdk1(t, k1, k_1)))
plt.plot(t, np.&lt;span style="color: #006FE0;"&gt;abs&lt;/span&gt;(dAdk_1(t, k1, k_1)))
plt.xlim([0, 0.5])
plt.ylim([0, 0.1])
plt.xlabel(&lt;span style="color: #008000;"&gt;'t'&lt;/span&gt;)
plt.legend([&lt;span style="color: #008000;"&gt;'$S_{k1}$'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'$S_{k\_1}$'&lt;/span&gt;])
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;img src="/media/ob-ipython-f3534f038e5e3a7c77041501838e9fdb.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
That looks like the figure in the paper. To summarize the main takeaway, autograd enabled us to readily compute derivatives without having to derive them manually. There was a little subtlety in choosing jacobian over grad or elementwise_grad but once you know what these do, it seems reasonable. It is important to import the wrapped numpy first, to enable autograd to do its work. All the functions here are pretty standard, so everything worked out of the box. We should probably be using autograd, or something like it for more things in science!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/11/15/Sensitivity-analysis-using-automatic-differentiation-in-Python.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.2&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Forces by automatic differentiation in molecular simulation]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2017/11/14/Forces-by-automatic-differentiation-in-molecular-simulation" />
    <id>http://jkitchin.github.io/blog/2017/11/14/Forces-by-automatic-differentiation-in-molecular-simulation</id>
    <updated>2017-11-14T21:06:22Z</updated>
    <published>2017-11-14T21:06:22Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="simulation" />
    <category scheme="http://jkitchin.github.io/blog" term="autograd" />
    <summary type="html"><![CDATA[Forces by automatic differentiation in molecular simulation]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2017/11/14/Forces-by-automatic-differentiation-in-molecular-simulation"><![CDATA[


&lt;p&gt;
In molecular simulation we often use a potential to compute the total energy of a system. For example, we might use something simple like a &lt;a href="https://en.wikipedia.org/wiki/Lennard-Jones_potential"&gt;Lennard-Jones&lt;/a&gt; potential. If we have a potential function, e.g. \(E = V(R)\) where \(R\) are the positions of the atoms, then we know the forces on the atoms are defined by \(f = -\frac{dV}{dR}\). For simple functions, you can derive the derivative pretty easily, but these functions quickly get complicated. In this post, we consider &lt;a href="https://en.wikipedia.org/wiki/Automatic_differentiation"&gt;automatic differentiation&lt;/a&gt; as implemented by &lt;a href="https://github.com/HIPS/autograd"&gt;autograd&lt;/a&gt;. This is neither symbolic nor numerical differentiation. The gist is that the program uses the chain rule to evaluate derivatives. Here we do not delve into how it is done, we just see how it might help us in molecular simulation.
&lt;/p&gt;

&lt;p&gt;
For reference, here is a result from the LennardJones calculator in ASE.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org610d524"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; ase.calculators.lj &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; LennardJones
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; ase.cluster.icosahedron &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; Icosahedron

&lt;span style="color: #BA36A5;"&gt;atoms&lt;/span&gt; = Icosahedron(&lt;span style="color: #008000;"&gt;'Ar'&lt;/span&gt;, noshells=2, latticeconstant=3)
atoms.set_calculator(LennardJones())

atoms.rattle(0.5)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'LJ: '&lt;/span&gt;, atoms.get_potential_energy())
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
('LJ: ', -3.3553466825679812)

&lt;/pre&gt;

&lt;p&gt;
First, we define a function for the Lennard-Jones potential. I adapted the code &lt;a href="https://wiki.fysik.dtu.dk/ase/_modules/ase/calculators/lj.html#LennardJones"&gt;here&lt;/a&gt; to implement a function that calculates the Lennard-Jones energy for a cluster of atoms with no periodic boundary conditions. &lt;i&gt;Instead&lt;/i&gt; of using numpy directly, we import it from the autograd package which puts thin wrappers around the functions to enable the derivative calculations. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org022fb09"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; autograd.numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;energy&lt;/span&gt;(positions):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;"Compute the energy of a Lennard-Jones system."&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;natoms&lt;/span&gt; = &lt;span style="color: #006FE0;"&gt;len&lt;/span&gt;(positions)

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;sigma&lt;/span&gt; = 1.0
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;epsilon&lt;/span&gt; = 1.0
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;rc&lt;/span&gt; = 3 * sigma

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;e0&lt;/span&gt; = 4 * epsilon * ((sigma / rc)**12 - (sigma / rc)**6)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;energy&lt;/span&gt; = 0.0
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; a1 &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;range&lt;/span&gt;(natoms):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; j &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;range&lt;/span&gt;(a1 + 1, natoms):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;r2&lt;/span&gt; = np.&lt;span style="color: #006FE0;"&gt;sum&lt;/span&gt;((positions[a1] - positions[j])**2)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; r2 &amp;lt;= rc**2:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;c6&lt;/span&gt; = (sigma**2 / r2)**3
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;energy&lt;/span&gt; -= e0 
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;c12&lt;/span&gt; = c6**2
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;energy&lt;/span&gt; += 4 * epsilon * (c12 - c6)

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; energy
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is our function in action, and it produces the same result as the ASE calculator. So far there is nothing new.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org4bd1401"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'our func: '&lt;/span&gt;, energy(atoms.positions))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
('our func: ', -3.3553466825679803)

&lt;/pre&gt;

&lt;p&gt;
Now, we look at the forces from the ASE calculator. If you look at the ASE &lt;a href="https://wiki.fysik.dtu.dk/ase/_modules/ase/calculators/lj.html#LennardJones"&gt;code&lt;/a&gt; you will see that the formula for forces was analytically derived and accumulated in the loop.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org6dc5318"&gt;np.set_printoptions(precision=3, suppress=&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(atoms.get_forces())
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[[ 0.545  1.667  0.721]
 [-0.068  0.002  0.121]
 [-0.18   0.018 -0.121]
 [ 0.902 -0.874 -0.083]
 [ 0.901 -0.937 -1.815]
 [ 0.243 -0.19   0.063]
 [-0.952 -1.776 -0.404]
 [-0.562  1.822  1.178]
 [-0.235  0.231  0.081]
 [-0.023  0.204 -0.294]
 [ 0.221 -0.342 -0.425]
 [-5.385 -6.017  1.236]
 [ 4.593  6.193 -0.258]]

&lt;/pre&gt;

&lt;p&gt;
Now we look at how to use autograd for this purpose. We want an element-wise gradient of the total energy with respect to the positions. autograd returns functions, so we wrap it in another function so we can take the negative of that function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org2210bf9"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; elementwise_grad

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;forces&lt;/span&gt;(pos):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;dEdR&lt;/span&gt; = elementwise_grad(energy)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; -dEdR(pos)

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(forces(atoms.positions))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[[ 0.545  1.667  0.721]
 [-0.068  0.002  0.121]
 [-0.18   0.018 -0.121]
 [ 0.902 -0.874 -0.083]
 [ 0.901 -0.937 -1.815]
 [ 0.243 -0.19   0.063]
 [-0.952 -1.776 -0.404]
 [-0.562  1.822  1.178]
 [-0.235  0.231  0.081]
 [-0.023  0.204 -0.294]
 [ 0.221 -0.342 -0.425]
 [-5.385 -6.017  1.236]
 [ 4.593  6.193 -0.258]]

&lt;/pre&gt;

&lt;p&gt;
Here we show the results are the same from both approaches.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="orgc41aef4"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(np.allclose(atoms.get_forces(), forces(atoms.positions)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
True

&lt;/pre&gt;

&lt;p&gt;
Wow. We got forces without deriving a derivative, or using numerical finite differences, across loops, and conditionals. That is pretty awesome. You can easily modify the potential function now, without the need to rederive the force derivatives! This is an idea worth exploring further. In principle, it should be possible to include periodic boundary conditions and use autograd to compute stresses too. Maybe that will be a future post.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/11/14/Forces-by-automatic-differentiation-in-molecular-simulation.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.2&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication in J. Phys. Chem. Lett.]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2017/09/25/New-publication-in-J-Phys-Chem-Lett" />
    <id>http://jkitchin.github.io/blog/2017/09/25/New-publication-in-J-Phys-Chem-Lett</id>
    <updated>2017-09-26T07:16:16Z</updated>
    <published>2017-09-25T20:24:45Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <category scheme="http://jkitchin.github.io/blog" term="publication" />
    <summary type="html"><![CDATA[New publication in J. Phys. Chem. Lett.]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2017/09/25/New-publication-in-J-Phys-Chem-Lett"><![CDATA[


&lt;p&gt;
DFT calculations are extensively used to predict the chemical properties of metal alloy surfaces, but they are expensive which limits the number of calculations that can be practically be calculated. In this paper, we explore a perturbation approach known as alchemy to take previously calculated results and extend them to new compositions. We use oxygen reduction as a prototype reaction, and show that alchemy is often much faster than DFT, with an accuracy within 0.1 eV of the DFT. There are cases where the accuracy is not as good suggesting that further improvements to the perturbation model could be beneficial. Overall, alchemy appears to be a useful tool in high-throughput screening research.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;saravanan-2017-alchem-predic&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; =        {Alchemical Predictions for Computational Catalysis: Potential
                  and Limitations},
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; =         2017,
  &lt;span style="color: #BA36A5;"&gt;Author&lt;/span&gt; =       {Saravanan, Karthikeyan and Kitchin, John R. and von
                  Lilienfeld, O. Anatole and Keith, John A.},
  &lt;span style="color: #BA36A5;"&gt;Bdsk-Url-1&lt;/span&gt; =   {http://dx.doi.org/10.1021/acs.jpclett.7b01974},
  &lt;span style="color: #BA36A5;"&gt;Doi&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;10.1021/acs.jpclett.7b01974&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;Eprint&lt;/span&gt; =       {http://dx.doi.org/10.1021/acs.jpclett.7b01974},
  &lt;span style="color: #BA36A5;"&gt;Journal&lt;/span&gt; =      {The Journal of Physical Chemistry Letters},
  &lt;span style="color: #BA36A5;"&gt;Note&lt;/span&gt; =         {PMID: 28938798},
  &lt;span style="color: #BA36A5;"&gt;Number&lt;/span&gt; =       {ja},
  &lt;span style="color: #BA36A5;"&gt;Pages&lt;/span&gt; =        {null},
  &lt;span style="color: #BA36A5;"&gt;Url&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;http://dx.doi.org/10.1021/acs.jpclett.7b01974&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;Volume&lt;/span&gt; =       0,
}

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/acs.jpclett.7b01974'&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/09/25/New-publication-in-J.-Phys.-Chem.-Lett..org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Finding similar bibtex entries]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2017/09/16/Finding-similar-bibtex-entries" />
    <id>http://jkitchin.github.io/blog/2017/09/16/Finding-similar-bibtex-entries</id>
    <updated>2017-09-16T10:00:47Z</updated>
    <published>2017-09-16T10:00:47Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <category scheme="http://jkitchin.github.io/blog" term="similarity" />
    <summary type="html"><![CDATA[Finding similar bibtex entries]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2017/09/16/Finding-similar-bibtex-entries"><![CDATA[


&lt;p&gt;
A common task while writing scientific papers is citing previous research. I use org-ref extensively for that, and it makes it pretty easy to find similar references, e.g. that have common authors, or common keywords. It also lets me find similar articles in Web of Science or Scopus. Suppose that I have cited a particular paper, e.g. e &lt;a class='org-ref-reference' href="#boes-2016-neural-networ"&gt;boes-2016-neural-networ&lt;/a&gt;, and I want to find similar references to it that are &lt;i&gt;already&lt;/i&gt; in my bibtex file, and similar by &lt;i&gt;my definition&lt;/i&gt;. With org-ref I can easily search by keyword or author to find similar entries, but these are limited by what I search for, and they are not sorted. Today, I will explore the first step in a recommender system that calculates similarity, and provides a sorted list of candidates with the most relevant ones first. 
&lt;/p&gt;

&lt;p&gt;
The idea is to calculate some measure of similarity between the title of that reference, and the titles of other references in my bibtex file, and then sort them by similarity. This is the reference I want to find similar entries for:
&lt;/p&gt;

&lt;p&gt;
Boes, J. R., Groenenboom, M. C., Keith, J. A., &amp;amp; Kitchin, J. R., Neural network and Reaxff comparison for Au properties, Int. J. Quantum Chem., 116(13), 979–987 (2016).  &lt;a href="http://dx.doi.org/10.1002/qua.25115"&gt;http://dx.doi.org/10.1002/qua.25115&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
The first thing we do is read in our bibtex file, and print a representative entry.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; bibtexparser
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; bibtexparser.bparser &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; BibTexParser

&lt;span style="color: #0000FF;"&gt;with&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;open&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'/Users/jkitchin/Dropbox/bibliography/references.bib'&lt;/span&gt;) &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; bibtex_file:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;parser&lt;/span&gt; = BibTexParser()
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;bib_database&lt;/span&gt; = bibtexparser.load(bibtex_file, parser=parser)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;entries&lt;/span&gt; = bib_database.entries

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(entries[10])
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
{'author': 'Jaan Aarik and Aleks Aidla and V{\\"a}ino Sammelselg and Teet\nUustare', 'title': 'Effect of Growth Conditions on Formation of \\ce{TiO_2}-{II}\nThin Films in Atomic Layer Deposition Process', 'journal': 'Journal of Crystal Growth', 'volume': '181', 'number': '3', 'pages': '259 - 264', 'year': '1997', 'doi': '10.1016/S0022-0248(97)00279-0', 'link': 'http://www.sciencedirect.com/science/article/pii/S0022024897002790', 'issn': '0022-0248', 'ENTRYTYPE': 'article', 'ID': 'aarik-1997-effec-growt'}
&lt;/p&gt;

&lt;p&gt;
Each entry is a dictionary containing the fields and their values. For this exploration, I will only consider similarities between titles. The next step is we find which entry corresponds to the reference we want to find similarities to.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;ids&lt;/span&gt; = [e[&lt;span style="color: #008000;"&gt;'ID'&lt;/span&gt;] &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; e &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; entries]
&lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; = ids.index(&lt;span style="color: #008000;"&gt;'boes-2016-neural-networ'&lt;/span&gt;)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(entries[i])
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
{'author': 'Jacob R. Boes and Mitchell C. Groenenboom and John A. Keith\nand John R. Kitchin', 'title': 'Neural Network and {Reaxff} Comparison for {Au} Properties', 'journal': 'Int. J. Quantum Chem.', 'volume': '116', 'number': '13', 'pages': '979-987', 'year': '2016', 'doi': '10.1002/qua.25115', 'link': 'http://dx.doi.org/10.1002/qua.25115', 'issn': '1097-461X', 'keyword': 'Kohn-Sham density functional theory, neural networks, reactive\nforce fields, potential energy surfaces, machine learning', 'ENTRYTYPE': 'article', 'ID': 'boes-2016-neural-networ'}
&lt;/p&gt;

&lt;p&gt;
It is best if we make the entry we want to find similarities to the first one, so here we swap the first and i&lt;sup&gt;th&lt;/sup&gt; entries.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;entries[0], &lt;span style="color: #BA36A5;"&gt;entries&lt;/span&gt;[i] = entries[i], entries[0]
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, we prepare the list of strings to get similarities for. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;titles&lt;/span&gt; = [e.get(&lt;span style="color: #008000;"&gt;'title'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;''&lt;/span&gt;) &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; e &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; entries]
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
We will use &lt;a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf"&gt;term frequency–inverse document frequency&lt;/a&gt; to get a vector that represents each title, and then use &lt;a href="https://en.wikipedia.org/wiki/Cosine_similarity"&gt;cosine similarity&lt;/a&gt; as a measure of similarity. Here is the place to note that &lt;i&gt;I chose&lt;/i&gt; these, and could choose other ones too. Also, it is worth noting that in this measure of similarity I did &lt;i&gt;not&lt;/i&gt; choose which keywords to measure similarity on.
&lt;/p&gt;

&lt;p&gt;
The functionality for this is provided by &lt;a href="http://scikit-learn.org/stable/"&gt;sklearn&lt;/a&gt;. It has implemented functions for the algorithms above, and in just a few lines of code you get an array of tf-idf features to analyze. The array we get from our vectorizer contains normalized vectors, so we can get the cosine similarity just from a dot product of the vectors. The first row corresponds to the similarity of the first string to all the others. I want them sorted in descending order. The argsort function returns ascending order, so we use a trick to sort the negative of the similarity score which achieves that. There are certainly more advanced treatments of the text we could use by &lt;a href="http://scikit-learn.org/stable/modules/feature_extraction.html#customizing-the-vectorizer-classes"&gt;customizing the vectorizer&lt;/a&gt;, e.g. word stemming, but for now we neglect that.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; sklearn.feature_extraction.text &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; TfidfVectorizer

&lt;span style="color: #BA36A5;"&gt;vectorizer&lt;/span&gt; = TfidfVectorizer(stop_words=&lt;span style="color: #008000;"&gt;'english'&lt;/span&gt;)
&lt;span style="color: #BA36A5;"&gt;X&lt;/span&gt; = vectorizer.fit_transform(titles)

&lt;span style="color: #BA36A5;"&gt;cosine_similarities&lt;/span&gt; = (X * X.T).A[0]

&lt;span style="color: #BA36A5;"&gt;related_docs_indices&lt;/span&gt; = (-cosine_similarities).argsort()

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'The top 10 recommendations for {} are:\n'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(S[0]))
&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; i, j &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;enumerate&lt;/span&gt;(related_docs_indices[1:11]):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'{i}. {ID}: {title}, {author}\n'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(i=i + 1, **entries[j]))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The top 10 recommendations for Neural Network and {Reaxff} Comparison for {Au} Properties are:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;behler-2010-neural: Neural network potential-energy surfaces for atomistic&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
simulations, J{\"o}rg Behler
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;boes-2017-neural-networ: Neural Network Predictions of Oxygen Interactions on a Dynamic&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
{Pd} Surface, Jacob R. Boes and John R. Kitchin
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;eshet-2010-ab: Ab Initio Quality Neural-Network Potential for Sodium, Hagai Eshet and Rustam Z. Khaliullin and Thomas D. K{\"u}hne&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
and J{\"o}rg Behler and Michele Parrinello
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;behler-2014-repres-poten: Representing Potential Energy Surfaces By High-Dimensional&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
Neural Network Potentials, J Behler
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;behler-2007-gener-neural: Generalized Neural-Network Representation of High-Dimensional&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
Potential-Energy Surfaces, J{\"o}rg Behler and Michele Parrinello
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;artrith-2012-high: High-Dimensional Neural Network Potentials for Metal Surfaces:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
A Prototype Study for Copper, Nongnuch Artrith and J{\"o}rg Behler
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;behler-2015-const: Constructing High-Dimensional Neural Network Potentials: A&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
Tutorial Review, J{\"o}rg Behler
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;artrith-2011-high: High-Dimensional Neural-Network Potentials for Multicomponent&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
Systems: Applications To Zinc Oxide, Nongnuch Artrith and Tobias Morawietz and J{\"o}rg Behler
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;sosso-2012-neural-gete: Neural Network Interatomic Potential for the Phase Change&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
Material \ce{GeTe}, Gabriele C. Sosso and Giacomo Miceli and Sebastiano Caravati
and J{\"o}rg Behler and Marco Bernasconi
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;lorenz-2006-descr: Descriptions of Surface Chemical Reactions Using a Neural&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
Network Representation of the Potential-Energy Surface, S{\"o}nke Lorenz and Matthias Scheffler and Axel Gross
&lt;/p&gt;

&lt;p&gt;
It is evident that this is showing other references containing the words "neural network"! I guess that is a little disappointing, since these would just as easily been narrowed down in org-ref. On the other hand, they are sorted and grouped, which would not happen in org-ref. This is a comparison of pretty short strings (just the titles), so maybe this would be much more interesting if abstracts were also included. Including authors would give a different set as well (I tried it, and got a bunch of my own references!).
&lt;/p&gt;

&lt;p&gt;
I don't think it would be very difficult to get this into an Emacs selection tool, e.g. helm/ivy. Check this out:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; pycse.lisp

related_docs_indices[1:6].lisp
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;

&lt;/p&gt;

&lt;p&gt;
'(1592 1650 299 1751 103)'
&lt;/p&gt;


&lt;p&gt;
That is a result that can be read directly by lisp, so we could simply write the code above as a shell script that takes an argument, and returns a list of indices to sort the candidates on. The alternative is to implement this in elisp, perhaps via a dynamic module if there is already a good C library for this. My sense is the Python libraries are more advanced in functionality.
&lt;/p&gt;

&lt;p&gt;
This could have a number of other applications. Given some reference content, you could imagine finding emails that are similar to it, finding RSS entries that are similar to it, finding org headlines that are related, similar files, or similarity with any other set of strings that can be gathered, e.g. from Crossref or some other search, etc. I predict there will be more on these topics in the future!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/09/16/Finding-similar-bibtex-entries.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication in Journal of Physics Condensed Matter]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2017/08/06/New-publication-in-Journal-of-Physics-Condensed-Matter" />
    <id>http://jkitchin.github.io/blog/2017/08/06/New-publication-in-Journal-of-Physics-Condensed-Matter</id>
    <updated>2017-08-06T11:05:31Z</updated>
    <published>2017-08-06T11:04:51Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <category scheme="http://jkitchin.github.io/blog" term="publication" />
    <summary type="html"><![CDATA[New publication in Journal of Physics Condensed Matter]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2017/08/06/New-publication-in-Journal-of-Physics-Condensed-Matter"><![CDATA[


&lt;p&gt;
The Atomic Simulation Environment is a powerful python library for setting up, running and analyzing molecular simulations. I have been using it and contributing to it since around 2002 when I used the ASE-2 version in Python 1.5! The new ase-3 version is much simpler to use, and much more powerful. This paper describes some of its design principles and capabilities. If you use ASE, please cite this paper! 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;larsen-2017-atomic-simul&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;author&lt;/span&gt; =       {Ask Hjorth Larsen and Jens J{\o}rgen Mortensen and Jakob
                  Blomqvist and Ivano E Castelli and Rune Christensen and
                  Marcin Du&amp;#322;ak and Jesper Friis and Michael N Groves and
                  Bj{\o}rk Hammer and Cory Hargus and Eric D Hermes and Paul C
                  Jennings and Peter Bjerre Jensen and James Kermode and John
                  R Kitchin and Esben Leonhard Kolsbjerg and Joseph Kubal and
                  Kristen Kaasbjerg and Steen Lysgaard and J{\'o}n Bergmann
                  Maronsson and Tristan Maxson and Thomas Olsen and Lars
                  Pastewka and Andrew Peterson and Carsten Rostgaard and Jakob
                  Schi{\o}tz and Ole Sch{\"u}tt and Mikkel Strange and Kristian
                  S Thygesen and Tejs Vegge and Lasse Vilhelmsen and Michael
                  Walter and Zhenhua Zeng and Karsten W Jacobsen},
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; =        {The Atomic Simulation Environment-A Python Library for Working
                  With Atoms},
  &lt;span style="color: #BA36A5;"&gt;journal&lt;/span&gt; =      {Journal of Physics: Condensed Matter},
  &lt;span style="color: #BA36A5;"&gt;volume&lt;/span&gt; =       29,
  &lt;span style="color: #BA36A5;"&gt;number&lt;/span&gt; =       27,
  &lt;span style="color: #BA36A5;"&gt;pages&lt;/span&gt; =        273002,
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; =         2017,
  &lt;span style="color: #BA36A5;"&gt;url&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;http://stacks.iop.org/0953-8984/29/i=27/a=273002&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;abstract&lt;/span&gt; =     {The atomic simulation environment (ASE) is a software package
                  written in the Python programming language with the aim of
                  setting up, steering, and analyzing atomistic simulations. In
                  ASE, tasks are fully scripted in Python. The powerful syntax
                  of Python combined with the NumPy array library make it
                  possible to perform very complex simulation tasks. For
                  example, a sequence of calculations may be performed with the
                  use of a simple 'for-loop' construction. Calculations of
                  energy, forces, stresses and other quantities are performed
                  through interfaces to many external electronic structure codes
                  or force fields using a uniform interface. On top of this
                  calculator interface, ASE provides modules for performing many
                  standard simulation tasks such as structure optimization,
                  molecular dynamics, handling of constraints and performing
                  nudged elastic band calculations.},
}

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1088/1361-648X/aa680e'&gt;&lt;/div&gt; 
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/08/06/New-publication-in-Journal-of-Physics-Condensed-Matter.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication in Crystal Growth &amp; Design]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2017/08/05/New-publication-in-Crystal-Growth-Design" />
    <id>http://jkitchin.github.io/blog/2017/08/05/New-publication-in-Crystal-Growth-Design</id>
    <updated>2017-08-05T13:16:35Z</updated>
    <published>2017-08-05T13:11:22Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <category scheme="http://jkitchin.github.io/blog" term="publication" />
    <summary type="html"><![CDATA[New publication in Crystal Growth &amp; Design]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2017/08/05/New-publication-in-Crystal-Growth-Design"><![CDATA[


&lt;p&gt;
Usually, metal oxides grow in a single, most stable crystal structure at a particular set of conditions. For example, TiO&lt;sub&gt;2&lt;/sub&gt; grows in the rutile structure for a large range of pressure and temperature conditions, but under some conditions it can also grow in the anatase structure. In this paper we show that epitaxial stabilization can be used to influence which crystal structures are observed for the growth of tin oxide. Tin oxide is normally only observed in the rutile structure. We grew tin oxide as an epitaxial film on a poly-crystalline substrate of CoNb&lt;sub&gt;2&lt;/sub&gt;O&lt;sub&gt;6&lt;/sub&gt; which has an &amp;alpha;-PbO&lt;sub&gt;2&lt;/sub&gt; crystal structure. We found that both rutile and &amp;alpha;-PbO&lt;sub&gt;2&lt;/sub&gt; structures could be found in the film, and that the structure correlated with the orientation of the underlying grains. In other words, the orientation of a substrate can influence the structure of an epitaxial film, enabling one to grow films in crystal structures that may be metastable, and unobtainable in bulk samples.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;wittkamper-2017-compet-growt&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;author&lt;/span&gt; =       {Wittkamper, Julia and Xu, Zhongnan and Kombaiah, Boopathy and
                  Ram, Farangis and De Graef, Marc and Kitchin, John R. and
                  Rohrer, Gregory S. and Salvador, Paul A.},
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; =        {Competitive Growth of Scrutinyite (&lt;span style="color: #008000;"&gt;$\alpha$&lt;/span&gt;-PbO2) and Rutile
                  Polymorphs of \ce{SnO2} on All Orientations of Columbite
                  \ce{CoNb2O6} Substrates},
  &lt;span style="color: #BA36A5;"&gt;journal&lt;/span&gt; =      {Crystal Growth \&amp;amp; Design},
  &lt;span style="color: #BA36A5;"&gt;volume&lt;/span&gt; =       17,
  &lt;span style="color: #BA36A5;"&gt;number&lt;/span&gt; =       7,
  &lt;span style="color: #BA36A5;"&gt;pages&lt;/span&gt; =        {3929-3939},
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; =         2017,
  &lt;span style="color: #BA36A5;"&gt;doi&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;10.1021/acs.cgd.7b00569&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;url&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;https://doi.org/10.1021/acs.cgd.7b00569&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;eprint&lt;/span&gt; =       { http://dx.doi.org/10.1021/acs.cgd.7b00569 },
}

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/acs.cgd.7b00569'&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/08/05/New-publication-in-Crystal-Growth-&amp;-Design.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Overloading mathematical operators in elisp]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2017/07/23/Overloading-mathematical-operators-in-elisp" />
    <id>http://jkitchin.github.io/blog/2017/07/23/Overloading-mathematical-operators-in-elisp</id>
    <updated>2017-07-23T16:03:40Z</updated>
    <published>2017-07-23T14:13:41Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="elisp" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Overloading mathematical operators in elisp]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2017/07/23/Overloading-mathematical-operators-in-elisp"><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgccfe3c4"&gt;1. Addendum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
In Python I am used to some simple idioms like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;([1, 2, 3] * 2)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;"ab"&lt;/span&gt; * 3)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
[1, 2, 3, 1, 2, 3]
ababab
&lt;/p&gt;

&lt;p&gt;
There is even such fanciness as defining operators for objects, as long as they have the appropriate dunder methods defined:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;class&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;Point&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__init__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, x, y):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x = x
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y = y

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__str__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Point ({}, {})"&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x, &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y)

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__mul__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, a):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; Point(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x * a, &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y * a)

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__rmul__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, a):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; Point(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x * a, &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y * a)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   
&lt;span style="color: #BA36A5;"&gt;p&lt;/span&gt; = Point(1, 1)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(p * 2)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(3 * p)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Point (2, 2)
Point (3, 3)
&lt;/p&gt;

&lt;p&gt;
Out of the box, these things are not possible in elisp. Operators like  * in elisp only take numbers or markers. We have a few options to change this. The worst option is to simply redefine these functions. That is bad because it is not reversible. We could define new functions that have the behavior we want, but then we lose the semantic meaning of "*" that we were aiming for. A better option is to &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html"&gt;advise&lt;/a&gt; these functions. This is reversible, because you can later unadvise them. Today we look at some strategies to do this.
&lt;/p&gt;

&lt;p&gt;
We will use "around" advise because it will let us bypass the original intent of the function when we want to, or use it when we do. First, we create a function that will be the advice and add it to the * function. This first draft won't actually change the behavior of *; if all the args are numbers or markers it will simply use the original function as before.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;dash&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;*--*-around&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"if every arg is a number do *, else do something else."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   ((-every? (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (numberp x) (markerp x))) args)
    (apply orig-fun args))))

(advice-add '* &lt;span style="color: #006FE0;"&gt;:around&lt;/span&gt; #'*--*-around)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Let's just confirm
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(* 1 2 3)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
6

&lt;/pre&gt;

&lt;p&gt;
Now, we can start modifying our function to handle some other cases. Let's do the list and string first. The * function is variadic, but in these cases it makes sense to limit to two arguments. We need two cases for each type since we can write (* 2 list) or (* list 2). We also should create a fall-through case that raises an error to alert us we can't multiply things.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;*--*-around&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"if every arg is a number do *, else do something else."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;The original behavior&lt;/span&gt;
   ((-every? (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (numberp x) (markerp x))) args)
    (apply orig-fun args))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;create repeated copies of list&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (listp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (second args) append (copy-list (first args))))

   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (integerp (first args))
         (listp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (first args) append (copy-list (second args))))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Make repeated string&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (stringp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (second args) concat (first args)))

   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (integerp (first args))
         (stringp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (first args) concat (second args)))

   (t
    (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"You cannot * %s"&lt;/span&gt; args))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
*--*-around

&lt;/pre&gt;

&lt;p&gt;
Here is the new advice in action. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(list
 (* '(a b) 2)
 (* 2 '(c d))
 (* 2 &lt;span style="color: #008000;"&gt;"ab"&lt;/span&gt;)
 (* &lt;span style="color: #008000;"&gt;"cd"&lt;/span&gt; 2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;(a b a b)&lt;/td&gt;
&lt;td class="org-left"&gt;(c d c d)&lt;/td&gt;
&lt;td class="org-left"&gt;abab&lt;/td&gt;
&lt;td class="org-left"&gt;cdcd&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That captures the spirit of overloading * for lists and strings. What about that object example? We have to make some assumptions here. Python looks for an uses a dunder &lt;span class="underline"&gt;&lt;span class="underline"&gt;mul&lt;/span&gt;&lt;/span&gt; method. We will assume a double dash method (&amp;#x2013;mul&amp;#x2013;) in a similar spirit. We have to modify the advice one final time. We just add a condition to check if one of the arguments is an eieio-object, and then call the &amp;#x2013;mul&amp;#x2013; function on the arguments.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;*--*-around&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"if every arg is a number do *, else do something else."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;The original behavior&lt;/span&gt;
   ((-every? (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (numberp x) (markerp x))) args)
    (apply orig-fun args))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;create repeated copies of list&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (listp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (second args) append (copy-list (first args))))

   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (integerp (first args))
         (listp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (first args) append (copy-list (second args))))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Make repeated string&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (stringp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (second args) concat (first args)))

   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (integerp (first args))
         (stringp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (first args) concat (second args)))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Handle object&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (eieio-object-p (first args))
             (numberp (second args)))
        (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (numberp (first args))
             (eieio-object-p (second args))))
    (apply '--mul-- args))

   (t
    (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"You cannot * %s"&lt;/span&gt; args))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
*--*-around

&lt;/pre&gt;

&lt;p&gt;
Now, we can define a class and the &amp;#x2013;mul&amp;#x2013; function and show that our overloaded * function works. Note we can define two signatures of &amp;#x2013;mul&amp;#x2013; so it is not necessary to define an &amp;#x2013;rmul&amp;#x2013; in this case as it was with Python (although we still create two functions in the end).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;eieio&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defclass&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;Point&lt;/span&gt; ()
  ((x &lt;span style="color: #006FE0;"&gt;:initarg&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt;)
   (y &lt;span style="color: #006FE0;"&gt;:initarg&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt;)))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;--mul--&lt;/span&gt; ((p Point) a)
  (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; (* (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt;) a) &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; (* (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt;) a)))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;--mul--&lt;/span&gt; (a (p Point))
  (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; (* (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt;) a) &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; (* (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt;) a)))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;--str--&lt;/span&gt; ((p Point))
  (format &lt;span style="color: #008000;"&gt;"Point (%s, %s)"&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt;) (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt;)))

(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((P (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; 1)))
  (list
   (--str-- (* P 2))
   (--str-- (* 3 P))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Point (2, 2)&lt;/td&gt;
&lt;td class="org-left"&gt;Point (3, 3)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That is pretty awesome. Before going on, here is how you remove the advice:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(advice-remove '* '*--*-around)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This example has been pretty instructive. You have to handle overloading for all the intrinsic types. We did lists and strings here; you might also consider vectors. For objects, it looks like we can at least try using a generic method like &amp;#x2013;mul&amp;#x2013;. One detail I neglected to consider here is that * is natively variadic. For these special cases, we did not implement variadic versions. This isn't a feature of Python which uses infix notation, so every call is with two arguments. In some cases it might make sense to support variadic args, but that seems like a generally challenging thing to do. While (* "a" 2 3) might be expected to create a string of "aaaaaa", (* "a" 2 '(3)) doesn't make sense at all.
&lt;/p&gt;

&lt;p&gt;
It would be straightforward to extend this to other operators like '+ to concatenate strings, lists and vectors, or '- to remove chars or elements, including extensions to objects using double-dash functions like &amp;#x2013;add&amp;#x2013;, &amp;#x2013;subtract&amp;#x2013;, etc. Another nice idea might be to advise print to use &amp;#x2013;str&amp;#x2013; on objects.
&lt;/p&gt;

&lt;p&gt;
On the surface this looks useful so far. Python defines &lt;i&gt;a lot&lt;/i&gt; of dunder methods that cover all kinds of scenarios including logical comparisons, bit shifting, mod, incrementing operators, casting, comparisons, right/left operations, indexing and assignment, length and others. That would be a lot of advices. This approach is moderately tedious to expand though; you have to keep adding conditional cases. 
&lt;/p&gt;

&lt;p&gt;
An alternative to the big conditional statement used in the advice might be the use of a &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Generic-Functions.html"&gt;generic function&lt;/a&gt;. With this approach we define a generic function that just does multiplication by default. Then we define specific cases with specific signatures that are used for lists, strings, objects, etc. That is basically all our conditional above was doing, matching signatures and executing a chunk of code accordingly.
&lt;/p&gt;

&lt;p&gt;
Here is our default case that does the original behavior. We still use advice to apply the function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defgeneric&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"Generic multiply for when no specific case exists."&lt;/span&gt;
  (apply orig-fun args))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;*--*-around-generic&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  (apply 'generic-multiply orig-fun args))

(advice-add '* &lt;span style="color: #006FE0;"&gt;:around&lt;/span&gt; #'*--*-around-generic)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That should just work as usual for regular multiplication.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(* 1 2 3 4)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
24

&lt;/pre&gt;

&lt;p&gt;
Sure enough it does. Now, we can define a specific method for a string. We need a specialized method for each signature, e.g. pre and post multiplication.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (s string) (n integer))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below n concat s))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (n integer) (s string))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below n concat s))

(list
 (* &lt;span style="color: #008000;"&gt;"Ac"&lt;/span&gt; 2)
 (* 2 &lt;span style="color: #008000;"&gt;"Ad"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;AcAc&lt;/td&gt;
&lt;td class="org-left"&gt;AdAd&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That works fine, and we did not have to modify our original advice function at all! Next the  list:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (L list) (n integer))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below n append (copy-list L)))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (n integer) (L list))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below n append (copy-list L)))

(list (* '(1 2) 2)
      (* 2 '(3 4)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That also works fine. Last, our class example. This should work on all objects I think (unless there is some way to make classes that do not inherit the default superclass).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (n integer) (obj eieio-default-superclass))
  (--mul-- n obj))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (obj eieio-default-superclass) (n integer))
  (--mul-- n obj))

(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((P (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; 1)))
  (list
   (--str-- (* P 2))
   (--str-- (* 3 P))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Point (2, 2)&lt;/td&gt;
&lt;td class="org-left"&gt;Point (3, 3)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
This is a much better approach to extending the multiplication operator! If I continue this path in the future I would probably take this one.  This could be useful to make elisp more like some more popular contemporary languages like Python, as well as to add linear algebra like notation or mathematical operations on objects in elisp. It kind of feels like these operations ought to be generic functions to start with to make this kind of overloading easier from the beginning.  Functions like "*" are currently defined in the C source code though, maybe for performance reasons. It is not obvious what the consequences of making them generic might be.
&lt;/p&gt;

&lt;div id="outline-container-orgccfe3c4" class="outline-2"&gt;
&lt;h2 id="orgccfe3c4"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Addendum&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Christopher Wellons &lt;a href="http://disq.us/p/1kr76r9"&gt;pointed out&lt;/a&gt; an important limitation of advice: they don't work on byte-compiled functions. Let's see what he means. Here is a simple function that will just multiply a Point object by an integer:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;to-be-bytten&lt;/span&gt; (p1 n)
  (* p1 n))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
to-be-bytten

&lt;/pre&gt;

&lt;p&gt;
Here it is in action, and here it works fine.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(to-be-bytten (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; 1) 2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[eieio-class-tag--Point 2 2]

&lt;/pre&gt;

&lt;p&gt;
Now, let's byte-compile that function and try it again:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(byte-compile 'to-be-bytten)

(&lt;span style="color: #0000FF;"&gt;condition-case&lt;/span&gt; err
    (to-be-bytten (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; 1) 2)
  ((&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; r)
   (message &lt;span style="color: #008000;"&gt;"Doh! Christopher was right. It did not work...\n%s"&lt;/span&gt; err)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Doh! Christopher was right. It did not work...
(wrong-type-argument number-or-marker-p [eieio-class-tag--Point 1 1])

&lt;/pre&gt;

&lt;p&gt;
So the advice is pretty limited since most of the functions in Emacs core are likely to be byte-compiled, and it might mean you have to redefine * completely, or define some new function that looks like it. Too bad, the advice was pretty easy! 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/07/23/Overloading-mathematical-operators-in-elisp.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Linear algebra in Emacs using MKL and dynamic modules]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules" />
    <id>http://jkitchin.github.io/blog/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules</id>
    <updated>2017-07-21T15:48:05Z</updated>
    <published>2017-07-21T15:48:05Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <category scheme="http://jkitchin.github.io/blog" term="dynamic-module" />
    <summary type="html"><![CDATA[Linear algebra in Emacs using MKL and dynamic modules]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules"><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgbfb8d4e"&gt;1. Convenience functions to get array properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga1c9a60"&gt;2. Matrix multiplication&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgf536480"&gt;2.1. 1d * 1d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org76f193d"&gt;2.2. 2d * 1d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org82cc641"&gt;2.3. 1d * 2d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0849c80"&gt;2.4. 2d * 2d&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4a14b46"&gt;3. Summary thoughts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgba66efb"&gt;4. The module code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4be1bce"&gt;5. Elisp helper functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
In a &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules/"&gt;previous post&lt;/a&gt; I integrated some linear algebra into Emacs using the GNU Scientific library and a dynamic module. In this post, I use a similar approach that uses the Intel MKL library in conjunction with some helper elisp functions to mimic the array broadcasting features in Numpy. I thought this might be easier and lead to at least a complementary set of functionalities.
&lt;/p&gt;

&lt;p&gt;
Note: I had to follow the directions &lt;a href="http://osxdaily.com/2015/10/05/disable-rootless-system-integrity-protection-mac-os-x"&gt;here&lt;/a&gt; to disable some security feature on my Mac so that it would use the MKL libraries. Thanks Apple.
&lt;/p&gt;

&lt;p&gt;
It is convenient to use vectors for the representation of arrays in Emacs because there are nice functions in the emacs-module.h for accessing vector properties. Also vectors sound closer to an array than a list. So what about array broadcasting, e.g. the way numpy lets you multiply a 2d array with a 1d array? If you multiply two arrays with size (m1, n1) * (m2, n2), it is required that the number of columns in the first array (n1) be equal to the number of rows in the second one (m2), and the resulting size of the array product will be (m1, n2). What should happen though when we have 1d array? This is neither a row or column vector itself, but we can treat as either one if we choose too. For example the vector [1 2 3] can be thought of as an array with the shape (1, 3), e.g. a single row with three columns, or (3, 1), i.e. three rows in a single column. We will build this capability into the module for convenience.
&lt;/p&gt;

&lt;p&gt;
I still find it moderately tedious to write c functions that take emacs arguments, transform them to c arguments, do some c computations, and convert the results back to emacs values. So, we only implement one c function for this that multiplies two 2d arrays together using the cblas_dgemm routine in the MKL library. Then, we will create a complementary elisp library that will provide some additional functionality to get the shapes of vector arrays, dimensions, and allow us to multiply 1d and 2d vectors together the same way Numpy does array broadcasting.
&lt;/p&gt;

&lt;p&gt;
The dynamic module code is listed in &lt;a href="#orgba66efb"&gt;The module code&lt;/a&gt;. The elisp code is listed in &lt;a href="#org4be1bce"&gt;Elisp helper functions&lt;/a&gt;.  In the following sections we just demonstrate how to use the results.
&lt;/p&gt;

&lt;div id="outline-container-orgbfb8d4e" class="outline-2"&gt;
&lt;h2 id="orgbfb8d4e"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Convenience functions to get array properties&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
I found it convenient to do array shape and dimension analysis in elisp before sending arrays to the dynamic module. The shape of an array is just the number of elements in each dimension. Here we look at a 2&amp;times; 3 array.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(vector-shape [[1 2 3]
               [3 4 5]])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[2 3]

&lt;/pre&gt;

&lt;p&gt;
You see it returns a vector showing two rows and three columns. There are two convenience commands to get the number of rows (vector-nrows) and columns (vector-ncols). Here is one of them.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(vector-ncols [[1 2 3]
               [3 4 5]])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
3

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orga1c9a60" class="outline-2"&gt;
&lt;h2 id="orga1c9a60"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Matrix multiplication&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
The main problem we want to calculate is the matrix multiplication \(A\cdotB\) where \(A\) and \(B\) are either 1d vectors or 2d arrays. Here we examine several representative cases of matrix multiplication.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf536480" class="outline-3"&gt;
&lt;h3 id="orgf536480"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; 1d * 1d&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
This is a simple dot-product that is actually calculated in elisp.
&lt;/p&gt;

&lt;p&gt;
\([1 1 1] \cdot [2 2 2] = 6\)
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(matrix-multiply [1 1 1] [2 2 2])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
6.0

&lt;/pre&gt;

&lt;p&gt;
✓
&lt;/p&gt;

&lt;p&gt;
Note we get a float. That is because we initialize the sum with 0.0 to be consistent with all the other cases which are done with floats. dgemm is a double routine in MKL, which means it should return floats. Internally in the module, we cast all numbers as doubles for the multiplication.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org76f193d" class="outline-3"&gt;
&lt;h3 id="org76f193d"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; 2d * 1d&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
This is a matrix multiplication that is typically like \(A b\) where \(b\) is a column vector. We return a 1d array as a result, rather than a 2d array of nrows and 1 column.
&lt;/p&gt;

&lt;p&gt;
\[ \left[\begin{array}{cc}
1 &amp; 2 \\
3 &amp; 4 \end{array}\right] 
\left [ \begin{array}{c}
1 \\ 1 \end{array}\right] = \left[\begin{array}{c}3\\7\end{array}\right]\]
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((A [[1 2]
          [3 4]])
      (b [1 1]))
  (matrix-multiply  A b))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[3.0 7.0]

&lt;/pre&gt;

&lt;p&gt;
✓
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org82cc641" class="outline-3"&gt;
&lt;h3 id="org82cc641"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; 1d * 2d&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
This case is \(b A\) where \(b\) is a row vector. For example:
&lt;/p&gt;

&lt;p&gt;
\[\left[\begin{array}{cc}1 &amp; 1\end{array}\right]
\left[\begin{array}{cc} 1 &amp; 2\\ 3 &amp; 4\end{array}\right] = \left[\begin{array}{cc} 4 &amp; 6 \end{array}\right ]\]
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(matrix-multiply [1 1]
                 [[1 2]
                  [3 4]])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[4.0 6.0]

&lt;/pre&gt;

&lt;p&gt;
✓
&lt;/p&gt;

&lt;p&gt;
As with the previous case, we return a 1d vector result rather than a 2d array with 1 row and ncolumns.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0849c80" class="outline-3"&gt;
&lt;h3 id="org0849c80"&gt;&lt;span class="section-number-3"&gt;2.4&lt;/span&gt; 2d * 2d&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
Finally we have the case of \(A B\). The number of columns in A must be the same as the number of rows in B, and the result has a size that is the number of rows in A and the number of columns in B. Here is one &lt;a href="http://www.sosmath.com/matrix/matrix1/matrix1.html"&gt;example&lt;/a&gt;:
&lt;/p&gt;

&lt;p&gt;
\[\left[\begin{array}{cc} 0 &amp; 1\\ 0 &amp; 0\end{array}\right]  
\left[\begin{array}{cc} 0 &amp; 0\\ 1 &amp; 0\end{array}\right]  
= \left[\begin{array}{cc} 1 &amp; 0\\ 0 &amp; 0\end{array}\right]  \]
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(matrix-multiply [[0 1]
                  [0 0]]
                 [[0 0]
                  [1 0]])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[[1.0 0.0] [0.0 0.0]]

&lt;/pre&gt;

&lt;p&gt;
✓
&lt;/p&gt;

&lt;p&gt;
This example is adapted from &lt;a href="https://stackoverflow.com/questions/21547462/how-to-multiply-2-dimensional-arrays-matrix-multiplication"&gt;here&lt;/a&gt;. The correct answer is at the bottom of that page, and shown here.
&lt;/p&gt;

&lt;p&gt;
\[\left[\begin{array}{cccc} 1 &amp; 2 &amp; -2 &amp; 0 \\ -3 &amp; 4 &amp; 7 &amp; 2 \\ 6 &amp; 0 &amp; 3 &amp; 1\end{array}\right]  
\left[\begin{array}{cc} -1 &amp; 3 \\ 0 &amp; 9 \\ 1 &amp; -11 \\ 4 &amp; -5 \end{array}\right]
= \left[\begin{array}{cc} -3 &amp; 43 \\ 18 &amp; -60 \\ 4 &amp; -5\end{array}\right]    \]
&lt;/p&gt;

&lt;p&gt;
For readability we use temporary variables here, and pretty-print the result.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((A [[1 2 -2 0]
          [-3 4 7 2]
          [6 0 3 1]])
      (B [[-1 3]
          [0  9]
          [1 -11]
          [4 -5]]))
  (pp (matrix-multiply A B)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[[-3.0 43.0]
 [18.0 -60.0]
 [1.0 -20.0]]

&lt;/pre&gt;

&lt;p&gt;
✓
&lt;/p&gt;

&lt;p&gt;
So, all these example work as we expect. The elisp function for matrix-multiply does a lot of work for you to make these cases work, including error checking for dimensional consistency.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4a14b46" class="outline-2"&gt;
&lt;h2 id="org4a14b46"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Summary thoughts&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
It was not any easier to write this dynamic module than the previous one I used with the Gnu Scientific Library. The approach and code are remarkably similar. In one way the GSL was easier to use; it worked out of the box, whereas I had to fiddle with a security option in my OS to get it to run MKL! My  Anaconda Python distribution must get around that somehow since it ships with an MKL compiled Numpy and scipy.
&lt;/p&gt;

&lt;p&gt;
The idea of using elisp for analysis of the inputs and making sure they are correct is a good one and helps prevent segfaults. Of course it is a good idea to write defensive c-code to avoid that too. Overall, this is another good example of expanding the capabilities of Emacs with a dynamic module.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgba66efb" class="outline-2"&gt;
&lt;h2 id="orgba66efb"&gt;&lt;a id="ID-45D04B39-1927-44ED-9402-E89D166AE8C8"&gt;&lt;/a&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; The module code&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
The c-code is loosely adapted from &lt;a href="https://software.intel.com/en-us/node/529735"&gt;https://software.intel.com/en-us/node/529735&lt;/a&gt;. We do not implement the full dgemm behavior which is able to calculate \(C = \alpha A * B + \beta*C\). We set &amp;alpha;=1, and &amp;beta;=0 in this example. We should do some dimension checking here, but it is easier to do it in emacs in a helper function. As long as you use the helper function there should not be an issue, but it is possible to segfault Emacs if you use the module function incorrectly.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-c"&gt;&lt;span style="color: #808080;"&gt;#include&lt;/span&gt; &lt;span style="color: #008000;"&gt;"emacs-module.h"&lt;/span&gt;
&lt;span style="color: #808080;"&gt;#include&lt;/span&gt; &lt;span style="color: #008000;"&gt;"emacs-module-helpers.h"&lt;/span&gt;
&lt;span style="color: #808080;"&gt;#include&lt;/span&gt; &lt;span style="color: #008000;"&gt;&amp;lt;mkl.h&amp;gt;&lt;/span&gt;

&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;plugin_is_GPL_compatible&lt;/span&gt;;

&lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #006699;"&gt;Fmkl_dgemm&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;emacs_env&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;env&lt;/span&gt;, &lt;span style="color: #6434A3;"&gt;ptrdiff_t&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;nargs&lt;/span&gt;, &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;args&lt;/span&gt;[], &lt;span style="color: #6434A3;"&gt;void&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;data&lt;/span&gt;)
{
  &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;A&lt;/span&gt;, *&lt;span style="color: #BA36A5;"&gt;B&lt;/span&gt;, *&lt;span style="color: #BA36A5;"&gt;C&lt;/span&gt;;
  &lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;m&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;n&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;k&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;j&lt;/span&gt;;
  &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;alpha&lt;/span&gt; = 1.0;
  &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;beta&lt;/span&gt; = 0.0;
  
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;These will be 2d vectors&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;M0&lt;/span&gt; = args[0]; &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;array 1 - A (m x k)&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;M1&lt;/span&gt; = args[1]; &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;array 2 - B (k x n)&lt;/span&gt;

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;I need to get the number of rows and columns of each one.&lt;/span&gt;
  m = env-&amp;gt;vec_size(env, M0);
  k  = 0;
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;We assume that we have a 2d array.&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;el1&lt;/span&gt; = env-&amp;gt;vec_get (env, M0, 0);
  k = env-&amp;gt;vec_size(env, el1);
  
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Now we know A has dimensions (m, k)&lt;/span&gt;
 
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;el2&lt;/span&gt; = env-&amp;gt;vec_get (env, M1, 0);
  n = env-&amp;gt;vec_size(env, el2);
  
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Now we know M1 had dimensions (k, n)&lt;/span&gt;
  
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Now we have to build up arrays.&lt;/span&gt;
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;We are looking at a * b = c&lt;/span&gt;
  A = (&lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; *)mkl_malloc( m*k*&lt;span style="color: #0000FF;"&gt;sizeof&lt;/span&gt;( &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; ), 64 );
  B = (&lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; *)mkl_malloc( k*n*&lt;span style="color: #0000FF;"&gt;sizeof&lt;/span&gt;( &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; ), 64 );
  C = (&lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; *)mkl_malloc( m*n*&lt;span style="color: #0000FF;"&gt;sizeof&lt;/span&gt;( &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; ), 64 );
  &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (A == &lt;span style="color: #D0372D;"&gt;NULL&lt;/span&gt; || B == &lt;span style="color: #D0372D;"&gt;NULL&lt;/span&gt; || C == &lt;span style="color: #D0372D;"&gt;NULL&lt;/span&gt;) {
    printf( &lt;span style="color: #008000;"&gt;"\n ERROR: Can't allocate memory for matrices. Aborting... \n\n"&lt;/span&gt;);
    mkl_free(A);
    mkl_free(B);
    mkl_free(C);
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 1;
  }

  &lt;span style="color: #8D8D84;"&gt;//&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;populate A&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;row&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;ij&lt;/span&gt;;
  &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; = 0; i &amp;lt; m; i++)
    {
      row = env-&amp;gt;vec_get(env, M0, i);
      &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;j&lt;/span&gt; = 0; j &amp;lt; k; j++)
        {
          &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;get M0[i, j]&lt;/span&gt;
          ij = env-&amp;gt;vec_get(env, row, j);
          A[k * i + j] = extract_double(env, ij);
        }
    }

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;populate B&lt;/span&gt;
  &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; = 0; i &amp;lt; k; i++)
    {
      row = env-&amp;gt;vec_get(env, M1, i);
      &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;j&lt;/span&gt; = 0; j &amp;lt; n; j++)
        {         
          &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;get M0[i, j]&lt;/span&gt;
          ij = env-&amp;gt;vec_get(env, row, j);
          B[n * i + j] = extract_double(env, ij);
        }
    }

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;initialize C.  The solution will have dimensions of (rows1, cols2).&lt;/span&gt;
  &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; = 0; i &amp;lt; m; i++)
    {
      &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;j&lt;/span&gt; = 0; j &amp;lt; n; j++)
        {
          C[n * i + j] = 0.0;
        }
    }

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;the multiplication is done here.&lt;/span&gt;
  cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, 
                m, n, k, alpha, A, k, B, n, beta, C, n);

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;now we build up the vector to return&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;vector&lt;/span&gt; = env-&amp;gt;intern(env, &lt;span style="color: #008000;"&gt;"vector"&lt;/span&gt;);
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;array&lt;/span&gt; = malloc(&lt;span style="color: #0000FF;"&gt;sizeof&lt;/span&gt;(emacs_value) * m);
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;row1&lt;/span&gt;;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;vec&lt;/span&gt;;
  &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; = 0; i &amp;lt; m; i++)
    {
      row1 = malloc(&lt;span style="color: #0000FF;"&gt;sizeof&lt;/span&gt;(emacs_value) * n);
      &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;j&lt;/span&gt; = 0; j &amp;lt; n; j++)
        {
          row1[j] = env-&amp;gt;make_float(env, C[j + i * n]);
        }
      vec = env-&amp;gt;funcall(env, vector, n, row1);
      array[i] = vec;
      free(row1);
    }

  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;result&lt;/span&gt; = env-&amp;gt;funcall(env, vector, m, array);
  free(array);
  &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; result;
}


&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #006699;"&gt;emacs_module_init&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;struct&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;emacs_runtime&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;ert&lt;/span&gt;)
{
  &lt;span style="color: #6434A3;"&gt;emacs_env&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;env&lt;/span&gt; = ert-&amp;gt;get_environment(ert);
  
  DEFUN(&lt;span style="color: #008000;"&gt;"mkl-dgemm"&lt;/span&gt;, Fmkl_dgemm, 2, 2,
        &lt;span style="color: #008000;"&gt;"(mkl-dgemm A B)\n"&lt;/span&gt;\
        &lt;span style="color: #008000;"&gt;"Multiply the matrices A and B. A and B must both be 2d vectors.\n"&lt;/span&gt; \
        &lt;span style="color: #008000;"&gt;"Returns the product as a vector."&lt;/span&gt;,
        &lt;span style="color: #D0372D;"&gt;NULL&lt;/span&gt;);
  provide(env, &lt;span style="color: #008000;"&gt;"mkl"&lt;/span&gt;);
  
  &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 0;
}

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
To build this we have to run &lt;a href="org-babel-tangle"&gt;org-babel-tangle&lt;/a&gt; to generate the mkl.c file, and then run this shell block to compile it.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;sh /opt/intel/mkl/bin/mklvars.sh intel64
gcc -Wall -m64 -I${&lt;span style="color: #BA36A5;"&gt;MKLROOT&lt;/span&gt;}/include -fPIC -c mkl.c
gcc -shared -L${&lt;span style="color: #BA36A5;"&gt;MKLROOT&lt;/span&gt;}/lib -Wl,-rpath,${&lt;span style="color: #BA36A5;"&gt;MKLROOT&lt;/span&gt;}/lib -lmkl_rt -lpthread -lm -ldl -L. -lemacs-module-helpers -o mkl.so mkl.o
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org4be1bce" class="outline-2"&gt;
&lt;h2 id="org4be1bce"&gt;&lt;a id="ID-F5AEAF4E-317F-48D4-9815-8EB0331AF0E5"&gt;&lt;/a&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; Elisp helper functions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
We will often want to know the shape of our arrays. The shape is how many elements there are in each dimension. Here we define a recursive function that gets the shape of arbitrarily nested vectors and returns a vector of the shape. We define some helper functions to get the number of dimensions, elements, rows and columns.
&lt;/p&gt;

&lt;p&gt;
The main function is a helper elisp function that multiplies two arrays. The function analyzes the shapes and transforms 1d vectors into the right 2d shape to multiply them together, and then returns the shape that makes sense. The c-code is not very robust to mistakes in the array dimensions. It tends to make emacs segfault if you get it wrong. So we try to avoid that if possible.
&lt;/p&gt;

&lt;p&gt;
We have four cases to consider for multiplication:
&lt;/p&gt;

&lt;dl class="org-dl"&gt;
&lt;dt&gt;2d * 2d&lt;/dt&gt;&lt;dd&gt;(assert (= m1 n2)) return (n1, m2)&lt;/dd&gt;
&lt;dt&gt;1d * 2d&lt;/dt&gt;&lt;dd&gt;1d is a row vector (1, n1) (assert (= n1 m2)) return vector with n2 elements&lt;/dd&gt;
&lt;dt&gt;2d * 1d&lt;/dt&gt;&lt;dd&gt;1d is a column vector (m2, 1) (assert (= n1 m2)) return vector with m2 elements&lt;/dd&gt;
&lt;dt&gt;1d * 1d&lt;/dt&gt;&lt;dd&gt;(assert (= (length m1) (length m2)) return a scalar&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;
Here is the 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(add-to-list 'load-path (expand-file-name &lt;span style="color: #008000;"&gt;"."&lt;/span&gt;))
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;mkl&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;cl&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;seq&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;vector-shape&lt;/span&gt; (vec)
  &lt;span style="color: #036A07;"&gt;"Return a vector of the shape of VEC."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((shape (vector (length vec))))
    (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (vectorp (aref vec 0))
        (vconcat shape (vector-shape (aref vec 0)))
      shape)))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;vector-ndims&lt;/span&gt; (vec)
  &lt;span style="color: #036A07;"&gt;"Returns the number of dimensions in VEC."&lt;/span&gt;
  (length (vector-shape vec)))


(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;vector-numel&lt;/span&gt; (vec)
  &lt;span style="color: #036A07;"&gt;"Returns the number of elements in VEC."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (&amp;gt; (length vec) 0)
      (seq-reduce '* (vector-shape vec) 1)
    0))


(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;vector-nrows&lt;/span&gt; (vec)
 &lt;span style="color: #036A07;"&gt;"Return the number of rows in VEC."&lt;/span&gt;
 (aref (vector-shape vec) 0))


(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;vector-ncols&lt;/span&gt; (vec)
 &lt;span style="color: #036A07;"&gt;"Return the number of columns in VEC."&lt;/span&gt;
 (aref (vector-shape vec) 1))


(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;matrix-multiply&lt;/span&gt; (A B)
  &lt;span style="color: #036A07;"&gt;"Return A * B in the matrix multiply sense."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;1d * 1d i.e. a dot-product&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (= 1 (vector-ndims A))
         (= 1 (vector-ndims B))
         (= (length A) (length B)))
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;this is easy to compute so we don't use dgemm.&lt;/span&gt;
    (seq-reduce '+ (mapcar* (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (a b) (* a b)) A B) 0.0))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;2d * 1d (m1, n1) * (n2, 1)&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (= 2 (vector-ndims A))
         (= 1 (vector-ndims B))
         &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;ncols-A = len-B&lt;/span&gt;
         (= (vector-ncols A) (length B)))
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;transform B into a 2d column vector&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((B2d (apply 'vector (mapcar 'vector B)))
           (result  (mkl-dgemm A B2d)))
      &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Now call (dgemm A B2d) -&amp;gt; (m2, 1) column vector&lt;/span&gt;
      &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;and convert it back to a 1d result&lt;/span&gt;
      (cl-map 'vector (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (v) (aref v 0)) result)))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;1d * 2d (1, n1) * (m2, n2) len-A = nrows-B&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (= 1 (vector-ndims A))
         (= 2 (vector-ndims B))
         (= (length A) (vector-nrows B)))
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;transform B into a 2d row vector&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((A2d (vector A))
           (result  (mkl-dgemm A2d B)))
      &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;should be a 2d row vector&lt;/span&gt;
      (aref result 0)))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;2d * 2d (m1, n1) * (m2, n2) rows-A = ncols-B&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (= 2 (vector-ndims A))
         (= 2 (vector-ndims B))
         (= (vector-ncols A)
            (vector-nrows B)))
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;call (dgemm A B) and return result&lt;/span&gt;
    (mkl-dgemm A B))
   (t
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Error checking, getting here means none of the cases above were caught.&lt;/span&gt;
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;something is probably wrong.&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
     ((&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (&amp;gt; (vector-ndims A) 2)
          (&amp;gt; (vector-ndims B) 2))
      (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"One of your arrays has more than 2 dimensions. Only 1 or 2d arrays are supported"&lt;/span&gt;))
     ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (= 1 (vector-ndims A))
           (= 1 (vector-ndims B))
           (not (= (length A) (length B))))
      (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"A and B must be the same length.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;len(A) = %d&lt;/span&gt;
&lt;span style="color: #008000;"&gt;len(B) = %d"&lt;/span&gt; (length A) (length B)))
     ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt;
       (= (vector-ndims A) 2)
       (= (vector-ndims B) 2)
       (not (= (vector-nrows A) (vector-ncols B))))
      (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Your array shapes are not correct.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;The number of rows in array A must equal the number of columns in array B.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;There are %d rows in A and %d columns in B"&lt;/span&gt; (vector-nrows A) (vector-ncols B)))
     ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt;
       (= (vector-ndims A) 2)
       (= (vector-ndims B) 1)
       (not (= (vector-nrows A) (length B))))
      (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Your array shapes are not correct.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;The number of rows in array A must equal the number of columns in array B.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;There are %d rows in A and %d columns in B"&lt;/span&gt; (vector-nrows A) (length B)))
     (t
      (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Unknown error"&lt;/span&gt;))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
matrix-multiply

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[An Emacs zeromq library using an ffi]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2017/07/13/An-Emacs-zeromq-library-using-an-ffi" />
    <id>http://jkitchin.github.io/blog/2017/07/13/An-Emacs-zeromq-library-using-an-ffi</id>
    <updated>2017-07-13T06:44:23Z</updated>
    <published>2017-07-13T06:44:23Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="zeromq" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <category scheme="http://jkitchin.github.io/blog" term="ffi" />
    <category scheme="http://jkitchin.github.io/blog" term="dynamic-module" />
    <summary type="html"><![CDATA[An Emacs zeromq library using an ffi]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2017/07/13/An-Emacs-zeromq-library-using-an-ffi"><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org9367268"&gt;1. Summary thoughts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4003ff3"&gt;2. Modified ffi-define-function macro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org77956c2"&gt;3. The zeromq bindings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
An alternative approach to writing your own dynamic module (which requires some proficiency in c) is to use a foreign function interface (ffi). There is one for emacs at &lt;a href="https://github.com/tromey/emacs-ffi"&gt;https://github.com/tromey/emacs-ffi&lt;/a&gt;, and it is also a dynamic module itself that uses &lt;a href="https://github.com/libffi/libffi"&gt;libffi&lt;/a&gt;. This lets you use elisp to create functions in Emacs that actually call functions in some other library installed on your system. Here, we use this module to recreate our zeromq bindings that I previously &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules/"&gt;posted&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
The emacs-ffi module works fine as it is, but I found it useful to redefine one of the main macros (define-ffi-function) with the following goals in mind:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Allow me to specify the argument names and docstrings for each arg that contain its type and a description of the arg.&lt;/li&gt;
&lt;li&gt;Document what each function returns (type and description).&lt;/li&gt;
&lt;li&gt;Combine those two things into an overall docstring on the function.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
These are important to me because it allows Emacs to work at its fullest potential while writing elisp code, including having the right function signatures in eldoc, and easy access to documentation of each function. You can see the new definition &lt;a href="#org4003ff3"&gt;here&lt;/a&gt;. For example, here is a docstring for zmq-send using that new macro:
&lt;/p&gt;

&lt;pre class="example"&gt;
zmq-send is a Lisp function.

(zmq-send *SOCKET *MSG LEN FLAGS)

For more information check the manuals.

send a message part on a socket.
http://api.zeromq.org/4-2:zmq-send

*SOCKET (:pointer) Pointer to a socket.
*MSG (:pointer) Pointer to a C-string to send
LEN (:size_t) Number of bytes to send
FLAGS (:int) 

Returns: Number of bytes sent or -1 on failure. (:int)
&lt;/pre&gt;

&lt;p&gt;
That has everything you need to know
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-send-ori &lt;span style="color: #008000;"&gt;"zmq_send"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:size_t&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt;) zmq)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
zmq-send-ori

&lt;/pre&gt;

&lt;p&gt;
Compare that to this docstring from the original macro. 
&lt;/p&gt;

&lt;pre class="example"&gt;
zmq-send-ori is a Lisp function.

(zmq-send-ori G251 G252 G253 G254)

For more information check the manuals.
&lt;/pre&gt;

&lt;p&gt;
You can see the zeromq function definitions in elisp &lt;a href="#org77956c2"&gt;here&lt;/a&gt;. Here is a list of the functions we have created:
&lt;/p&gt;

&lt;pre class="example"&gt;
Type RET on a type label to view its full documentation.

zmq
  Function: Returns a pointer to the libzmq library.
zmq-close
  Function: close ØMQ socket.
zmq-connect
  Function: create outgoing connection from socket.
zmq-ctx-destroy
  Function: terminate a ØMQ context.
zmq-ctx-new
  Function: create new ØMQ context.
zmq-recv
  Function: receive a message part from a socket.
zmq-send
  Function: send a message part on a socket.
zmq-socket
  Function: create ØMQ socket.
&lt;/pre&gt;

&lt;p&gt;
Now we can use these to create the client, this time in elisp. Just as in the last post, you need to run the hwserver in a terminal for this to work. Here is the client code.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((context (zmq-ctx-new))
       (socket (zmq-socket context ZMQ-REQ)))

  (&lt;span style="color: #0000FF;"&gt;with-ffi-string&lt;/span&gt; (endpoint &lt;span style="color: #008000;"&gt;"tcp://localhost:5555"&lt;/span&gt;)
    (zmq-connect socket endpoint))

  (&lt;span style="color: #0000FF;"&gt;with-ffi-string&lt;/span&gt; (msg &lt;span style="color: #008000;"&gt;"Hi there"&lt;/span&gt;)
    (zmq-send socket msg 5 0))

  (&lt;span style="color: #0000FF;"&gt;with-ffi-string&lt;/span&gt; (recv (make-string 10 &lt;span style="color: #008000;"&gt;""&lt;/span&gt;))
    (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((status -1))
      (&lt;span style="color: #0000FF;"&gt;cl-loop&lt;/span&gt; do (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; status (zmq-recv socket recv 10 0)) until (not (= -1 status)))) 
    (print (ffi-get-c-string recv)))

  (zmq-close socket)
  (zmq-ctx-destroy context))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;

"World     "

&lt;/pre&gt;

&lt;p&gt;
This client basically performs the same as the previously one we built. You can see we are mixing some programming styles here. For example, we have to create pointers to string variables in advance that the ffi will be writing to later like we would do in c. We use the with-ffi-string macro which frees the pointer when we are done with it. It basically just avoids me having to create, use, and destroy the pointers myself. So, there it is, a working elisp zeromq client!
&lt;/p&gt;


&lt;div id="outline-container-org9367268" class="outline-2"&gt;
&lt;h2 id="org9367268"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Summary thoughts&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
For this example, I feel like the ffi approach here (with my modified function making macro) was much easier than what I previously did with a compiled c-library (although it benefited a lot from my recent work on the c-library). I really like working in elisp, which is a much greater strength of mine than programming in c. It is pretty clear, however, that you have to know how c works to use this, otherwise it isn't so obvious that some functions will return a status, and do something by side effect, e.g. put results in one of the arguments. The signatures of the ffi functions are basically limited by the signatures of the c-functions. If you want to change the signature in Emacs, you have to write wrapper functions to do that.
&lt;/p&gt;

&lt;p&gt;
The macro I used here to create the functions creates really good (the kind I like anyway) docstrings when you use it fully. That isn't a totally new idea, I tried it out &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/03/22/A-better-defun-for-emacs-lisp/"&gt;here&lt;/a&gt; before.  In contrast, the original version not only didn't have a docstring, but every arg had a gensym (i.e. practically random) name! I think it would be very difficult to get the same level of documentation when writing c-code to make a module. In the c-code, there is a decoupling of the definition of a c-function (which always has the same signature) that gets data from the Emacs env, e.g. arguments, does stuff with them, and creates data to put back into the env, and the emacs_module_init function where you declare these functions to Emacs and tell it what to call the function in emacs, about how many arguments it takes, etc&amp;#x2026; The benefit of this is you define what the Emacs signature will look like, and then write the c-function that does the required work. The downside of this is the c-function and Emacs declarations are often far apart in the editor, and there is no easy way to auto-generate docstrings like I can with lisp macros. You would have to manually build them up yourself, and keep them synchronized. Also, I still have not figured out how to get emacs to show the right signature for c-generated functions.
&lt;/p&gt;

&lt;p&gt;
The ffi approach still uses a dynamic module approach, so it still requires a modern Emacs with the module compiled and working. It still requires (in this case) the zeromq library to be installed on the system too. Once you have those, however, the elisp zeromq bindings by this approach is done &lt;i&gt;completely in elisp&lt;/i&gt;!
&lt;/p&gt;

&lt;p&gt;
It will be interesting in the coming weeks to see how this approach works with the GNU Scientific Library, particularly with arrays. Preliminary work shows that while the elisp ffi code is &lt;i&gt;much&lt;/i&gt; shorter and easier to write than the corresponding c-code for some examples (e.g. a simple mathematical function), it is not as fast. So if performance is crucial, it may still pay off to write the c-code.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4003ff3" class="outline-2"&gt;
&lt;h2 id="org4003ff3"&gt;&lt;a id="ID-A2B7F051-EA53-4882-A978-05FAD211BB81"&gt;&lt;/a&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Modified ffi-define-function macro&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
Here are two macros I modified to add docstrings and named arguments too.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;define-ffi-library&lt;/span&gt; (symbol name)
  &lt;span style="color: #036A07;"&gt;"Create a pointer named to the c library."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((library (cl-gensym))
        (docstring (format &lt;span style="color: #008000;"&gt;"Returns a pointer to the %s library."&lt;/span&gt; name)))
    (set library nil)
    `(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; ,symbol ()
       ,docstring
       (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; ,library
           (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; ,library (ffi--dlopen ,name))))))

(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;define-ffi-function&lt;/span&gt; (name c-name return args library &lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; docstring)
  &lt;span style="color: #036A07;"&gt;"Create an Emacs function from a c-function.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;NAME is a symbol for  the emacs function to create.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;C-NAME is a string of the c-function to use.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;RETURN is a type-keyword or (type-keyword docstring)&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;ARGS is a list of type-keyword or (type-keyword name &amp;amp;optional arg-docstring)&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;LIBRARY is a symbol usually defined by `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;define-ffi-library&lt;/span&gt;&lt;span style="color: #036A07;"&gt;'&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;DOCSTRING is a string for the function to be created.&lt;/span&gt;

&lt;span style="color: #036A07;"&gt;An overall docstring is created for the function from the arg and return docstrings.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;"&lt;/span&gt;
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Turn variable references into actual types; while keeping&lt;/span&gt;
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;keywords the same.&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((return-type (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (keywordp return)
                          return
                        (car return)))
         (return-docstring (format &lt;span style="color: #008000;"&gt;"Returns: %s (%s)"&lt;/span&gt;
                                   (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (listp return)
                                       (second return)
                                     &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
                                   return-type))
         (arg-types (vconcat (mapcar (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (arg)
                                       (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (keywordp arg)
                                           (symbol-value arg)
                                         &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;assume list (type-keyword name &amp;amp;optional doc)&lt;/span&gt;
                                         (symbol-value (car arg))))
                                     args)))
         (arg-names (mapcar (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (arg)
                              (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (keywordp arg)
                                  (cl-gensym)
                                &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;assume list (type-keyword name &amp;amp;optional doc)&lt;/span&gt;
                                (second arg)))
                            args))
         (arg-docstrings (mapcar (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (arg)
                                   (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
                                    ((keywordp arg)
                                     &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
                                    ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (listp arg) (= 3 (length arg)))
                                     (third arg))
                                    (t &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)))
                                 args))
         &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Combine all the arg docstrings into one string&lt;/span&gt;
         (arg-docstring (mapconcat 'identity
                                   (mapcar* (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (name type arg-doc)
                                              (format &lt;span style="color: #008000;"&gt;"%s (%s) %s"&lt;/span&gt;
                                                      (upcase (symbol-name name))
                                                      type
                                                      arg-doc))
                                            arg-names arg-types arg-docstrings)
                                   &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt;))
         (&lt;span style="color: #0000FF;"&gt;function&lt;/span&gt; (cl-gensym))
         (cif (ffi--prep-cif (symbol-value return-type) arg-types)))
    (set function nil)
    `(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; ,name (,@arg-names)
       ,(concat docstring &lt;span style="color: #008000;"&gt;"\n\n"&lt;/span&gt; arg-docstring &lt;span style="color: #008000;"&gt;"\n\n"&lt;/span&gt; return-docstring)
       (&lt;span style="color: #0000FF;"&gt;unless&lt;/span&gt; ,function
         (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; ,function (ffi--dlsym ,c-name (,library))))
       &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;FIXME do we even need a separate prep?&lt;/span&gt;
       (ffi--call ,cif ,function ,@arg-names))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
define-ffi-function

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org77956c2" class="outline-2"&gt;
&lt;h2 id="org77956c2"&gt;&lt;a id="ID-29C81B62-C0DF-44D4-AFE2-6EE239C70500"&gt;&lt;/a&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; The zeromq bindings&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
These define the ffi functions we use in this post. I use a convention that pointer args start with a * so they look more like the c arguments. I also replace all _ with - so it looks more lispy, and the function names are easier to type.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(add-to-list 'load-path (expand-file-name &lt;span style="color: #008000;"&gt;"."&lt;/span&gt;))
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;ffi&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;define-ffi-library&lt;/span&gt; zmq &lt;span style="color: #008000;"&gt;"libzmq"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-ctx-new &lt;span style="color: #008000;"&gt;"zmq_ctx_new"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Pointer to a context"&lt;/span&gt;)
  nil zmq
  &lt;span style="color: #008000;"&gt;"create new &amp;#216;MQ context.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-ctx-new"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-ctx-destroy &lt;span style="color: #008000;"&gt;"zmq_ctx_destroy"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; &lt;span style="color: #008000;"&gt;"status"&lt;/span&gt;)
  ((&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *context)) zmq
  &lt;span style="color: #008000;"&gt;"terminate a &amp;#216;MQ context.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-ctx-destroy"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-socket &lt;span style="color: #008000;"&gt;"zmq_socket"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Pointer to a socket."&lt;/span&gt;)
  ((&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *context &lt;span style="color: #008000;"&gt;"Created by `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;zmq-ctx-new &lt;/span&gt;&lt;span style="color: #008000;"&gt;'."&lt;/span&gt;) (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; type)) zmq
  &lt;span style="color: #008000;"&gt;"create &amp;#216;MQ socket.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-socket"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-close &lt;span style="color: #008000;"&gt;"zmq_close"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Status"&lt;/span&gt;)
  ((&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *socket &lt;span style="color: #008000;"&gt;"Socket pointer created by `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;zmq-socket&lt;/span&gt;&lt;span style="color: #008000;"&gt;'"&lt;/span&gt;)) zmq
  &lt;span style="color: #008000;"&gt;"close &amp;#216;MQ socket.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-close"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-connect &lt;span style="color: #008000;"&gt;"zmq_connect"&lt;/span&gt; 
  (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Status"&lt;/span&gt;)
  ((&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *socket &lt;span style="color: #008000;"&gt;"Socket pointer created by `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;zmq-socket&lt;/span&gt;&lt;span style="color: #008000;"&gt;'"&lt;/span&gt;)
   (&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *endpoint &lt;span style="color: #008000;"&gt;"Char pointer, e.g. (ffi-make-c-string \"tcp://localhost:5555\")"&lt;/span&gt;))
  zmq
  &lt;span style="color: #008000;"&gt;"create outgoing connection from socket.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-connect"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-send &lt;span style="color: #008000;"&gt;"zmq_send"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Number of bytes sent or -1 on failure."&lt;/span&gt;)
  ((&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *socket &lt;span style="color: #008000;"&gt;"Pointer to a socket."&lt;/span&gt;)
   (&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *msg &lt;span style="color: #008000;"&gt;"Pointer to a C-string to send"&lt;/span&gt;)
   (&lt;span style="color: #006FE0;"&gt;:size_t&lt;/span&gt; len &lt;span style="color: #008000;"&gt;"Number of bytes to send"&lt;/span&gt;)
   (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; flags)) 
  zmq
   &lt;span style="color: #008000;"&gt;"send a message part on a socket.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-send"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-recv &lt;span style="color: #008000;"&gt;"zmq_recv"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Number of bytes received or -1 on failure."&lt;/span&gt;)
  ((&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *socket)
   (&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *buf &lt;span style="color: #008000;"&gt;"Pointer to c-string to put result in."&lt;/span&gt;)
   (&lt;span style="color: #006FE0;"&gt;:size_t&lt;/span&gt; len &lt;span style="color: #008000;"&gt;"Length to truncate message at."&lt;/span&gt;)
   (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; flags)) 
  zmq
   &lt;span style="color: #008000;"&gt;"receive a message part from a socket.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-recv"&lt;/span&gt;)


&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;We cannot get these through a ffi because the are #define'd for the CPP and&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;invisible in the library. They only exist in the zmq.h file.&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;defconst&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;ZMQ-REQ&lt;/span&gt; 3
  &lt;span style="color: #036A07;"&gt;"A socket of type ZMQ_REQ is used by a client to send requests&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  to and receive replies from a service. This socket type allows&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  only an alternating sequence of zmq_send(request) and&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  subsequent zmq_recv(reply) calls. Each request sent is&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  round-robined among all services, and each reply received is&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  matched with the last issued request."&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/07/13/An-Emacs-zeromq-library-using-an-ffi.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Zeromq bindings for Emacs via dynamic modules]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules" />
    <id>http://jkitchin.github.io/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules</id>
    <updated>2017-07-12T07:38:28Z</updated>
    <published>2017-07-12T07:38:28Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <category scheme="http://jkitchin.github.io/blog" term="dynamic-module" />
    <summary type="html"><![CDATA[Zeromq bindings for Emacs via dynamic modules]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules"><![CDATA[


&lt;p&gt;
I do a lot of scientific programming, and it is one of the reasons I have been learning to extend Emacs with dynamic modules. They have allowed me to add physical constants, numerical integration, root finding and linear algebra from established c-libraries to Emacs. Today I am taking a break from that and finally getting to another one of the reasons I started playing around with dynamic modules: &lt;a href="http://zguide.zeromq.org/"&gt;zeromq&lt;/a&gt;. Zeromq is a messaging library that &lt;a href="http://jupyter-client.readthedocs.io/en/latest/messaging.html"&gt;Jupyter&lt;/a&gt; uses to communicate with kernels. I thought we might get a smoother integration with Emacs and Jupyter if we could use zeromq directly to communicate between org-mode and the kernel. Currently we have to run a web server that does the communication for us via http requests. We won't solve the Jupyter problem today, but we will look at communicating with a Zeromq server from Emacs.
&lt;/p&gt;

&lt;p&gt;
This might have lots of other useful applications. Suppose Emacs could communicate directly with other zeromq servers to retrieve data from, perhaps scientific data. It might even be possible for Emacs to run its own zeromq server, and other instances of Emacs could then communicate with it. Collaborative editing anyone? 
&lt;/p&gt;

&lt;p&gt;
Here we just implement the "Hello world" client example in the &lt;a href="http://zguide.zeromq.org/page:all#Ask-and-Ye-Shall-Receive"&gt;zeromq guide&lt;/a&gt;. The code for the server, a c-client, the mod-zmq library, a makefile and tests can be found at &lt;a href="https://github.com/jkitchin/emacs-modules/tree/master/zeromq"&gt;https://github.com/jkitchin/emacs-modules/tree/master/zeromq&lt;/a&gt;. All the server does is receive a string, and then send a response (in this case just the string "World") back to the client. 
&lt;/p&gt;

&lt;p&gt;
To run this, make sure to run the hwserver executable in a terminal. I wrapped the  zeromq commands required to implement the client into a dynamic module. Since this example focuses on strings, the module returns strings to Emacs. I am not sure if that is always the right thing to do, as zeromq more generically uses bytes, but I will have to wait until I know more about zeromq to know if this is an issue. 
&lt;/p&gt;

&lt;p&gt;
This dynamic module uses a new feature that none of the previous posts used, and that is the user_ptr. These allow you to essentially return a reference pointer back to emacs that you can pass back to another function. That way they stay alive between function calls. For example, here we have to create a context and socket and pass these items to functions like zmq_send and zmq_recv.
&lt;/p&gt;

&lt;p&gt;
The directory this library is in is not on my path, so we load it like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(add-to-list 'load-path (expand-file-name &lt;span style="color: #008000;"&gt;"."&lt;/span&gt;))
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;mod-zmq&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here are the functions and their signatures that have been implemented so far. I only implemented the ones I needed for the client. The signatures may change in the future; this is just a proof of concept for now for the purpose of building the client.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(apropos-command &lt;span style="color: #008000;"&gt;"zmq*"&lt;/span&gt; t)
(&lt;span style="color: #0000FF;"&gt;with-current-buffer&lt;/span&gt; &lt;span style="color: #008000;"&gt;"*Apropos*"&lt;/span&gt; (buffer-string))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Type RET on a type label to view its full documentation.

zmq-close
  Function: (zmq-close SOCKET)
zmq-connect
  Function: (zmq-connect SOCKET ENDPOINT)
zmq-ctx-destroy
  Function: (zmq-ctx-destroy CONTEXT)
zmq-ctx-new
  Function: (zmq-ctx-new)
zmq-recv
  Function: (zmq-recv SOCKET LEN FLAGS)
zmq-send
  Function: (zmq-send SOCKET BUF FLAGS)
zmq-socket
  Function: (zmq-socket CONTEXT TYPE)
&lt;/pre&gt;

&lt;p&gt;
You can see the c code for the client here: &lt;a href="/media/hwclient.c"&gt;hwclient.c&lt;/a&gt; . Here is a simple elisp version of the hwclient that basically does the same thing! The main difference is I added a while loop around the zmq-recv because sometimes it returns -1 and no result. So, here we loop until the return result is not -1. That seems to do the right thing.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((context (zmq-ctx-new))
       (socket (zmq-socket context ZMQ-REQ))
       (recv-ret -1)
       (result))

  (zmq-connect socket &lt;span style="color: #008000;"&gt;"tcp://localhost:5555"&lt;/span&gt;)
  (zmq-send socket &lt;span style="color: #008000;"&gt;"Hello"&lt;/span&gt; 0)

  (&lt;span style="color: #0000FF;"&gt;while&lt;/span&gt; (= recv-ret -1)
    (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; result (zmq-recv socket 10 0)
          recv-ret (second result)))

  (print result)

  (zmq-close socket)
  (zmq-ctx-destroy context))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;

("World" 5)

&lt;/pre&gt;

&lt;p&gt;
Basically this creates the context, then the socket, and connects to it on port 5555 of the localhost where the server is running. Then we send the string "Hello". The server returns the string "World" and tells us it sent 5 bytes. Then we close the socket and destroy the context. There is a lot of code in the module to make this happen. A lot of it is converting args in emacs functions to things we can use in c, running a few lines of zmq commands, and then code to convert those results back to emacs values. Finally, there is code to register each function and define docstrings for them. I am not totally convinced this is the best way to do this, but it does work! An alternative might be &lt;a href="https://github.com/tromey/emacs-ffi"&gt;emacs-ffi&lt;/a&gt;, which might enable most of this to be developed in just elisp. 
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content>
  </entry>
</feed>
