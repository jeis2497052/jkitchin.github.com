

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group: bvp</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>
      <li><a href="/group.html">Group</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Solving-BVPs-with-a-neural-network-and-autograd"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/11/27/Solving-BVPs-with-a-neural-network-and-autograd/" rel="bookmark" title="Permanent Link to Solving BVPs with a neural network and autograd">Solving BVPs with a neural network and autograd</a></h2>
      <p><small><span class="blog_post_date">Posted November 27, 2017 at 07:59 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/autograd/'>autograd</a>, <a href='/blog/category/bvp/'>bvp</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/11/27/Solving-BVPs-with-a-neural-network-and-autograd#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated November 27, 2017 at 08:00 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
In this <a href="http://kitchingroup.cheme.cmu.edu/blog/2013/03/11/Solving-the-Blasius-equation/">post</a> we solved a boundary value problem by discretizing it, and approximating the derivatives by finite differences. Here I explore using a neural network to approximate the unknown function, autograd to get the required derivatives, and using autograd to train the neural network to satisfy the differential equations. We will look at the Blasius equation again.
</p>

\begin{eqnarray}
f''' + \frac{1}{2} f f'' &=& 0 \\
f(0) &=& 0 \\
f'(0) &=& 0 \\
f'(\infty) &=& 1
\end{eqnarray}

<p>
Here I setup a simple neural network
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad, elementwise_grad
<span style="color: #0000FF;">import</span> autograd.numpy.random <span style="color: #0000FF;">as</span> npr
<span style="color: #0000FF;">from</span> autograd.misc.optimizers <span style="color: #0000FF;">import</span> adam

<span style="color: #0000FF;">def</span> <span style="color: #006699;">init_random_params</span>(scale, layer_sizes, rs=npr.RandomState(0)):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #036A07;">"""Build a list of (weights, biases) tuples, one for each layer."""</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> [(rs.randn(insize, outsize) * scale,   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">weight matrix</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>rs.randn(outsize) * scale)           <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">bias vector</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> insize, outsize <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(layer_sizes[:-1], layer_sizes[1:])]


<span style="color: #0000FF;">def</span> <span style="color: #006699;">swish</span>(x):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #036A07;">"see https://arxiv.org/pdf/1710.05941.pdf"</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> x / (1.0 + np.exp(-x))


<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(params, inputs):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #036A07;">"Neural network functions"</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> W, b <span style="color: #0000FF;">in</span> params:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">outputs</span> = np.dot(inputs, W) + b
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">inputs</span> = swish(outputs)    
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> outputs

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Here is our initial guess of params:</span>
<span style="color: #BA36A5;">params</span> = init_random_params(0.1, layer_sizes=[1, 8, 1])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Derivatives</span>
<span style="color: #BA36A5;">fp</span> = elementwise_grad(f, 1)
<span style="color: #BA36A5;">fpp</span> = elementwise_grad(fp, 1)
<span style="color: #BA36A5;">fppp</span> = elementwise_grad(fpp, 1)

<span style="color: #BA36A5;">eta</span> = np.linspace(0, 6).reshape((-1, 1))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">This is the function we seek to minimize</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(params, step):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">These should all be zero at the solution</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">f''' + 0.5 f'' f = 0</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">zeq</span> = fppp(params, eta) + 0.5 * f(params, eta) * fpp(params, eta) 
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">bc0</span> = f(params, 0.0)  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">equal to zero at solution</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">bc1</span> = fp(params, 0.0)  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">equal to zero at solution</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">bc2</span> = fp(params, 6.0) - 1.0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">this is the one at "infinity"</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.mean(zeq**2) + bc0**2 + bc1**2 + bc2**2

<span style="color: #0000FF;">def</span> <span style="color: #006699;">callback</span>(params, step, g):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> step % 1000 == 0:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">"Iteration {0:3d} objective {1}"</span>.<span style="color: #006FE0;">format</span>(step,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> objective(params, step)))

<span style="color: #BA36A5;">params</span> = adam(grad(objective), params,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> step_size=0.001, num_iters=10000, callback=callback) 

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'f(0) = {}'</span>.<span style="color: #006FE0;">format</span>(f(params, 0.0)))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'fp(0) = {}'</span>.<span style="color: #006FE0;">format</span>(fp(params, 0.0)))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'fp(6) = {}'</span>.<span style="color: #006FE0;">format</span>(fp(params, 6.0)))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'fpp(0) = {}'</span>.<span style="color: #006FE0;">format</span>(fpp(params, 0.0)))

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(eta, f(params, eta))
plt.xlabel(<span style="color: #008000;">'$\eta$'</span>)
plt.ylabel(<span style="color: #008000;">'$f(\eta)$'</span>)
plt.xlim([0, 6])
plt.ylim([0, 4.5])
plt.savefig(<span style="color: #008000;">'nn-blasius.png'</span>)
</pre>
</div>

<p>
Iteration   0 objective 1.11472535
Iteration 1000 objective 0.00049768
Iteration 2000 objective 0.0004579
Iteration 3000 objective 0.00041697
Iteration 4000 objective 0.00037408
Iteration 5000 objective 0.00033705
Iteration 6000 objective 0.00031016
Iteration 7000 objective 0.00029197
Iteration 8000 objective 0.00027585
Iteration 9000 objective 0.00024616
f(0) = -0.00014613
fp(0) = 0.0003518041251639459
fp(6) = 0.999518061473252
fpp(0) = 0.3263370503702663
</p>

<p>
<img src="/media/nn-blasius.png"> 
I think it is worth discussing what we accomplished here. You can see we have arrived at an approximate solution to our differential equation and the boundary conditions. The boundary conditions seem pretty closely met, and the figure is approximately the same as the previous post. Even better, our solution is <i>an actual function</i> and not a numeric solution that has to be interpolated. We can evaluate it any where we want, including its derivatives!
</p>

<p>
We did not, however, have to convert the ODE into a system of first-order differential equations, and we did <i>not</i> have to approximate the derivatives with finite differences.
</p>

<p>
Note, however, that with finite differences we got <code>f''(0)=0.3325</code>. This <a href="https://www.calpoly.edu/~kshollen/ME347/Handouts/Blasius.pdf">site</a> reports <code>f''(0)=0.3321</code>. We get close to that here with <code>f''(0) = 0.3263</code>. We could probably get closer to this with more training to reduce the objective function further, or with a finer grid. It is evident that even after 9000 steps, it is still decreasing. Getting accurate derivatives is a stringent test for this, as they are measures of the function curvature.
</p>

<p>
It is hard to tell how broadly useful this is; I have not tried it beyond this example. In the past, I have found solving BVPs to be pretty sensitive to the initial guesses of the solution. Here we made almost no guess at all, and still got a solution. I find that pretty remarkable.
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/11/27/Solving-BVPs-with-a-neural-network-and-autograd.org">org-mode source</a></p>
<p>Org-mode version = 9.1.2</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/11/27/Solving-BVPs-with-a-neural-network-and-autograd#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Solving-the-Blasius-equation"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/03/11/Solving-the-Blasius-equation/" rel="bookmark" title="Permanent Link to Solving the Blasius equation">Solving the Blasius equation</a></h2>
      <p><small><span class="blog_post_date">Posted March 11, 2013 at 10:44 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/bvp/'>bvp</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/03/11/Solving-the-Blasius-equation#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated November 27, 2017 at 07:32 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
In fluid mechanics the Blasius equation comes up (<a href="http://en.wikipedia.org/wiki/Blasius_boundary_layer">http://en.wikipedia.org/wiki/Blasius_boundary_layer</a>) to describe the boundary layer that forms near a flat plate with fluid moving by it. The nonlinear differential equation is:
</p>

\begin{eqnarray}
f''' + \frac{1}{2} f f'' &=& 0 \\
f(0) &=& 0 \\
f'(0) &=& 0 \\
f'(\infty) &=& 1
\end{eqnarray}

<p>
This is a nonlinear, boundary value problem. The point of solving this equation is to get the value of \(f''(0)\) to evaluate the shear stress at the plate.
</p>

<p>
We have to convert this to a system of first-order differential equations. Let \(f_1 = f\), \(f_2 = f_1'\) and \(f_3 = f_2'\). This leads to:
</p>

\begin{eqnarray}
f_1' = f_2 \\
f_2' = f_3 \\
f_3' = -\frac{1}{2} f_1 f_3 \\
f_1(0) = 0 \\
f_2(0) = 0 \\
f_2(\infty) = 1
\end{eqnarray}

<p>
It is not possible to specify a boundary condition at \(\infty\) numerically, so we will have to use a large number, and verify it is "large enough". From the solution, we evaluate the derivatives at \(\eta=0\), and we have \(f''(0) = f_3(0)\).
</p>

<p>
We have to provide initial guesses for f_1, f_2 and f_3. This is the hardest part about this problem. We know that f_1 starts at zero, and is flat there (f'(0)=0), but at large eta, it has a constant slope of one. We will guess a simple line of slope = 1 for f_1. That is correct at large eta, and is zero at &eta;=0. If the slope of the function is constant at large \(\eta\), then the values of higher derivatives must tend to zero. We choose an exponential decay as a guess.
</p>

<p>
Finally, we let a solver iteratively find a solution for us, and find the answer we want. The solver is in the pycse module.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> pycse <span style="color: #0000FF;">import</span> bvp

<span style="color: #0000FF;">def</span> <span style="color: #006699;">odefun</span>(F, x):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">f1</span>, <span style="color: #BA36A5;">f2</span>, <span style="color: #BA36A5;">f3</span> = F.T
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.column_stack([f2,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   f3,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   -0.5 * f1 * f3])

<span style="color: #0000FF;">def</span> <span style="color: #006699;">bcfun</span>(Y):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">fa</span>, <span style="color: #BA36A5;">fb</span> = Y[0, :], Y[-1, :]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> [fa[0],        <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">f1(0) =  0</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   fa[1],        <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">f2(0) = 0</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   1.0 - fb[1]]  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">f2(inf) = 1</span>

<span style="color: #BA36A5;">eta</span> = np.linspace(0, 6, 100)
<span style="color: #BA36A5;">f1init</span> = eta
<span style="color: #BA36A5;">f2init</span> = np.exp(-eta)
<span style="color: #BA36A5;">f3init</span> = np.exp(-eta)

<span style="color: #BA36A5;">Finit</span> = np.column_stack([f1init, f2init, f3init])

<span style="color: #BA36A5;">sol</span> = bvp(odefun, bcfun, eta, Finit)
<span style="color: #BA36A5;">f1</span>, <span style="color: #BA36A5;">f2</span>, <span style="color: #BA36A5;">f3</span> = sol.T

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">"f''(0) = f_3(0) = {0}"</span>.<span style="color: #006FE0;">format</span>(f3[0]))

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(eta, f1)
plt.xlabel(<span style="color: #008000;">'$\eta$'</span>)
plt.ylabel(<span style="color: #008000;">'$f(\eta)$'</span>)
plt.savefig(<span style="color: #008000;">'images/blasius.png'</span>)
</pre>
</div>

<pre class="example">
f''(0) = f_3(0) = 0.3324911095517483

</pre>


<p>
<img src="/media/blasius.png"> 
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2017-05-17 Wed&gt; </span></span> You need pycse 1.6.4 for this example.
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2013/03/11/Solving-the-Blasius-equation.org">org-mode source</a></p>
<p>Org-mode version = 9.1.2</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/03/11/Solving-the-Blasius-equation#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Another-look-at-nonlinear-BVPs"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/03/11/Another-look-at-nonlinear-BVPs/" rel="bookmark" title="Permanent Link to Another look at nonlinear BVPs">Another look at nonlinear BVPs</a></h2>
      <p><small><span class="blog_post_date">Posted March 11, 2013 at 10:44 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/bvp/'>bvp</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/03/11/Another-look-at-nonlinear-BVPs#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 11, 2013 at 04:31 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
Adapted from <a href="http://www.mathworks.com/help/matlab/ref/bvp4c.html" >http://www.mathworks.com/help/matlab/ref/bvp4c.html</a>

</p>

<p>
Boundary value problems may have more than one solution. Let us consider the BVP:
</p>

\begin{eqnarray}
y'' + |y| &=& 0 \\
y(0) &=& 0 \\
y(4) &=& -2
\end{eqnarray}

<p>
We will see this equation has two answers, depending on your initial guess. We convert this to the following set of coupled equations:
</p>

\begin{eqnarray}
y_1' &=& y_2 \\
y_2' &=& -|y_1| \\
y_1(0)&=& 0\\
y_1(4) &=& -2
\end{eqnarray}

<p>
This BVP is nonlinear because of the absolute value. We will have to guess solutions to get started. We will guess two different solutions, both of which will be constant values.  We will use pycse.bvp to solve the equation.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> pycse <span style="color: #8b0000;">import</span> bvp
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">odefun</span>(Y, x):
    y1, y2 = Y
    dy1dx = y2
    dy2dx = -np.abs(y1)
    <span style="color: #8b0000;">return</span> [dy1dx, dy2dx]

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">bcfun</span>(Ya, Yb):
    y1a, y2a = Ya
    y1b, y2b = Yb

    <span style="color: #8b0000;">return</span> [y1a, -2 - y1b]

x = np.linspace(0, 4, 100)

y1 = 1.0 * np.ones(x.shape)
y2 = 0.0 * np.ones(x.shape)

Yinit = np.vstack([y1, y2])

sol = bvp(odefun, bcfun, x, Yinit)

plt.plot(x, sol[0])

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">another initial guess</span>
y1 = -1.0 * np.ones(x.shape)
y2 = 0.0 * np.ones(x.shape)

Yinit = np.vstack([y1, y2])

sol = bvp(odefun, bcfun, x, Yinit)

plt.plot(x, sol[0])
plt.legend([<span style="color: #228b22;">'guess 1'</span>, <span style="color: #228b22;">'guess 2'</span>])
plt.savefig(<span style="color: #228b22;">'images/bvp-another-nonlin-1.png'</span>)
plt.show()
</pre>
</div>


<p><img src="/img/./images/bvp-another-nonlin-1.png"><p>

<p>
This example shows that a nonlinear BVP may have different solutions, and which one you get depends on the guess you make for the solution. This is analogous to solving nonlinear algebraic equations (which is what is done in solving this problem!).
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/11/Another-look-at-nonlinear-BVPs.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/03/11/Another-look-at-nonlinear-BVPs#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Boundary-value-problem-in-heat-conduction"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/03/06/Boundary-value-problem-in-heat-conduction/" rel="bookmark" title="Permanent Link to Boundary value problem in heat conduction">Boundary value problem in heat conduction</a></h2>
      <p><small><span class="blog_post_date">Posted March 06, 2013 at 07:35 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/bvp/'>bvp</a></span> | tags: <a href='/blog/tag/heat-transfer/'>heat transfer</a>
        | <a href="http://jkitchin.github.io/blog/2013/03/06/Boundary-value-problem-in-heat-conduction#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 06, 2013 at 07:37 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/11/boundary-value-problem-in-heat-conduction/" >Matlab post</a>
</p>

<p>
For steady state heat conduction the temperature distribution in one-dimension is governed by the Laplace equation:
</p>

<p>
$$ \nabla^2 T = 0$$
</p>

<p>
with boundary conditions that at \(T(x=a) = T_A\) and \(T(x=L) = T_B\).
</p>

<p>
The analytical solution is not difficult here: \(T = T_A-\frac{T_A-T_B}{L}x\), but we will solve this by finite differences.
</p>

<p>
For this problem, lets consider a slab that is defined by x=0 to x=L, with \(T(x=0) = 100\), and \(T(x=L) = 200\). We want to find the function T(x) inside the slab.
</p>

<p>
We approximate the second derivative by finite differences as
</p>

<p>
\( f''(x) \approx \frac{f(x-h) - 2 f(x) + f(x+h)}{h^2} \)
</p>

<p>
Since the second derivative in this case is equal to zero, we have at each discretized node \(0 = T_{i-1} - 2 T_i + T_{i+1}\). We know the values of \(T_{x=0} = \alpha\) and \(T_{x=L} = \beta\).
</p>

<p>
\[A = \left [ \begin{array}{ccccc} %
 -2         & 1 & 0                    & 0 & 0 \\
1           & -2& 1 & 0 & 0 \\
0                    & \ddots               & \ddots               & \ddots & 0 \\
0                    & 0                    & 1 & -2 & 1 \\
0                    & 0                    & 0  & 1  & -2  \end{array} \right ] \]
</p>

<p>
\[ x = \left [ \begin{array}{c} T_1 \\ \vdots \\ T_N \end{array} \right ] \]
</p>

<p>
\[ b = \left [ \begin{array}{c} -T(x=0) \\
0 \\
\vdots \\
0 \\
-T(x=L) \end{array} \right] \]
</p>

<p>
These are linear equations in the unknowns \(x\) that we can easily solve. Here, we evaluate the solution.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">we use the notation T(x1) = alpha and T(x2) = beta</span>
x1 = 0; alpha = 100
x2 = 5; beta = 200

npoints = 100

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">preallocate and shape the b vector and A-matrix</span>
b = np.zeros((npoints, 1));
b[0] = -alpha
b[-1] = -beta

A = np.zeros((npoints, npoints));

<span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">now we populate the A-matrix and b vector elements</span>
<span style="color: #8b0000;">for</span> i <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(npoints ):
    <span style="color: #8b0000;">for</span> j <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(npoints):
        <span style="color: #8b0000;">if</span> j == i: <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the diagonal</span>
            A[i,j] = -2
        <span style="color: #8b0000;">elif</span> j == i - 1: <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">left of the diagonal</span>
            A[i,j] = 1
        <span style="color: #8b0000;">elif</span> j == i + 1: <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">right of the diagonal</span>
            A[i,j] = 1
 
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">solve the equations A*y = b for Y</span>
Y = np.linalg.solve(A,b)

x = np.linspace(x1, x2, npoints + 2)
y = np.hstack([alpha, Y[:,0], beta])

<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

plt.plot(x, y)

plt.plot(x, alpha + (beta - alpha)/(x2 - x1) * x, <span style="color: #228b22;">'r--'</span>)

plt.xlabel(<span style="color: #228b22;">'X'</span>)
plt.ylabel(<span style="color: #228b22;">'T(X)'</span>)
plt.legend((<span style="color: #228b22;">'finite difference'</span>, <span style="color: #228b22;">'analytical soln'</span>), loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/bvp-heat-conduction-1d.png'</span>)
</pre>
</div>

<p><img src="/img/./images/bvp-heat-conduction-1d.png"><p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/06/Boundary-value-problem-in-heat-conduction.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/03/06/Boundary-value-problem-in-heat-conduction#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Plane-Poiseuille-flow-BVP-solve-by-shooting-method"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/15/Plane-Poiseuille-flow-BVP-solve-by-shooting-method/" rel="bookmark" title="Permanent Link to Plane Poiseuille flow - BVP solve by shooting method">Plane Poiseuille flow - BVP solve by shooting method</a></h2>
      <p><small><span class="blog_post_date">Posted February 15, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/bvp/'>bvp</a></span> | tags: <a href='/blog/tag/fluids/'>fluids</a>
        | <a href="http://jkitchin.github.io/blog/2013/02/15/Plane-Poiseuille-flow-BVP-solve-by-shooting-method#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 08, 2013 at 10:08 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/08/plane-poiseuille-flow-bvp-solve-by-shooting-method/" >Matlab post</a>
</p>

<p>
One approach to solving BVPs is to use the shooting method. The reason we cannot use an initial value solver for a BVP is that there is not enough information at the initial value to start. In the shooting method, we take the function value at the initial point, and guess what the function derivatives are so that we can do an integration. If our guess was good, then the solution will go through the known second boundary point. If not, we guess again, until we get the answer we need. In this example we repeat the pressure driven flow example, but illustrate the shooting method.
</p>

<p>
In the pressure driven flow of a fluid with viscosity \(\mu\) between two stationary plates separated by distance \(d\) and driven by a pressure drop \(\Delta P/\Delta x\), the governing equations on the velocity \(u\) of the fluid are (assuming flow in the x-direction with the velocity varying only in the y-direction):
</p>

<p>
$$\frac{\Delta P}{\Delta x} = \mu \frac{d^2u}{dy^2}$$
</p>

<p>
with boundary conditions \(u(y=0) = 0\) and \(u(y=d) = 0\), i.e. the no-slip condition at the edges of the plate.
</p>

<p>
we convert this second order BVP to a system of ODEs by letting \(u_1 = u\), \(u_2 = u_1'\) and then \(u_2' = u_1''\). This leads to:
</p>

<p>
\(\frac{d u_1}{dy} = u_2\)
</p>

<p>
\(\frac{d u_2}{dy} = \frac{1}{\mu}\frac{\Delta P}{\Delta x}\)
</p>

<p>
with boundary conditions \(u_1(y=0) = 0\) and \(u_1(y=d) = 0\).
</p>

<p>
for this problem we let the plate separation be d=0.1, the viscosity \(\mu = 1\), and \(\frac{\Delta P}{\Delta x} = -100\).
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> First guess</h2>
<div class="outline-text-2" id="text-1">
<p>
We need u_1(0) and u_2(0), but we only have u_1(0). We need to guess a value for u_2(0) and see if the solution goes through the u_2(d)=0 boundary value.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

d = 0.1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plate thickness</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">odefun</span>(U, y):
    u1, u2 = U
    mu = 1
    Pdrop = -100
    du1dy = u2
    du2dy = 1.0 / mu * Pdrop
    <span style="color: #8b0000;">return</span> [du1dy, du2dy]

u1_0 = 0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">known</span>
u2_0 = 1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">guessed</span>

dspan = np.linspace(0, d)

U = odeint(odefun, [u1_0, u2_0], dspan)

plt.plot(dspan, U[:,0])
plt.plot([d],[0], <span style="color: #228b22;">'ro'</span>)
plt.xlabel(<span style="color: #228b22;">'d'</span>)
plt.ylabel(<span style="color: #228b22;">'$u_1$'</span>)
plt.savefig(<span style="color: #228b22;">'images/bvp-shooting-1.png'</span>)
</pre>
</div>

<p><img src="/img/./images/bvp-shooting-1.png"><p>

<p>
Here we have undershot the boundary condition. Let us try a larger guess.
</p>
</div>
</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Second guess</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

d = 0.1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plate thickness</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">odefun</span>(U, y):
    u1, u2 = U
    mu = 1
    Pdrop = -100
    du1dy = u2
    du2dy = 1.0 / mu * Pdrop
    <span style="color: #8b0000;">return</span> [du1dy, du2dy]

u1_0 = 0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">known</span>
u2_0 = 10 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">guessed</span>

dspan = np.linspace(0, d)

U = odeint(odefun, [u1_0, u2_0], dspan)

plt.plot(dspan, U[:,0])
plt.plot([d],[0], <span style="color: #228b22;">'ro'</span>)
plt.xlabel(<span style="color: #228b22;">'d'</span>)
plt.ylabel(<span style="color: #228b22;">'$u_1$'</span>)
plt.savefig(<span style="color: #228b22;">'images/bvp-shooting-2.png'</span>)
</pre>
</div>

<p><img src="/img/./images/bvp-shooting-2.png"><p>

<p>
Now we have clearly overshot. Let us now make a function that will iterate for us to find the right value.
</p>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Let fsolve do the work</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

d = 0.1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plate thickness</span>
Pdrop = -100
mu = 1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">odefun</span>(U, y):
    u1, u2 = U
    du1dy = u2
    du2dy = 1.0 / mu * Pdrop
    <span style="color: #8b0000;">return</span> [du1dy, du2dy]

u1_0 = 0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">known</span>
dspan = np.linspace(0, d)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">objective</span>(u2_0):
    dspan = np.linspace(0, d)
    U = odeint(odefun, [u1_0, u2_0], dspan)
    u1 = U[:,0]
    <span style="color: #8b0000;">return</span> u1[-1]

u2_0, = fsolve(objective, 1.0)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">now solve with optimal u2_0</span>
U = odeint(odefun, [u1_0, u2_0], dspan)

plt.plot(dspan, U[:,0], label=<span style="color: #228b22;">'Numerical solution'</span>)
plt.plot([d],[0], <span style="color: #228b22;">'ro'</span>)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plot an analytical solution</span>
u = -(Pdrop) * d**2 / 2 / mu * (dspan / d - (dspan / d)**2)
plt.plot(dspan, u, <span style="color: #228b22;">'r--'</span>, label=<span style="color: #228b22;">'Analytical solution'</span>)


plt.xlabel(<span style="color: #228b22;">'d'</span>)
plt.ylabel(<span style="color: #228b22;">'$u_1$'</span>)
plt.legend(loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/bvp-shooting-3.png'</span>)
</pre>
</div>

<p><img src="/img/./images/bvp-shooting-3.png"><p>

<p>
You can see the agreement is excellent!
</p>

<p>
This also seems like a useful bit of code to not have to reinvent regularly, so it has been added to pycse as BVP_sh. Here is an example usage.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> pycse <span style="color: #8b0000;">import</span> BVP_sh
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

d = 0.1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plate thickness</span>
Pdrop = -100
mu = 1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">odefun</span>(U, y):
    u1, u2 = U
    du1dy = u2
    du2dy = 1.0 / mu * Pdrop
    <span style="color: #8b0000;">return</span> [du1dy, du2dy]

x1 = 0.0; alpha = 0.0
x2 = 0.1; beta = 0.0
init = 2.0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">initial guess of slope at x=0</span>

X,Y = BVP_sh(odefun, x1, x2, alpha, beta, init)
plt.plot(X, Y[:,0])
plt.ylim([0, 0.14])

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plot an analytical solution</span>
u = -(Pdrop) * d**2 / 2 / mu * (X / d - (X / d)**2)
plt.plot(X, u, <span style="color: #228b22;">'r--'</span>, label=<span style="color: #228b22;">'Analytical solution'</span>)
plt.savefig(<span style="color: #228b22;">'images/bvp-shooting-4.png'</span>)
plt.show()
</pre>
</div>

<p><img src="/img/./images/bvp-shooting-4.png"><p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/15/Plane-Poiseuille-flow---BVP-solve-by-shooting-method.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/02/15/Plane-Poiseuille-flow-BVP-solve-by-shooting-method#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="/blog/category/bvp/2">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2017/11/27/Solving-BVPs-with-a-neural-network-and-autograd/">Solving BVPs with a neural network and autograd</a></li>
      <li><a href="/blog/2017/11/22/More-auto-differentiation-goodness-for-science-and-engineering/">More auto-differentiation goodness for science and engineering</a></li>
      <li><a href="/blog/2017/11/20/Timing-Lennard-Jones-implementations-ASE-vs-autograd/">Timing Lennard-Jones implementations - ASE vs autograd</a></li>
      <li><a href="/blog/2017/11/19/Training-the-ASE-Lennard-Jones-potential-to-DFT-calculations/">Training the ASE Lennard-Jones potential to DFT calculations</a></li>
      <li><a href="/blog/2017/11/18/Neural-networks-for-regression-with-autograd/">Neural networks for regression with autograd</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2017
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



