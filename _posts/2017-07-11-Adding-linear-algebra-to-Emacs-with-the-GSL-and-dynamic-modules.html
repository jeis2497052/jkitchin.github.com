---
title: Adding linear algebra to Emacs with the GSL and dynamic modules
date: 2017/07/11 10:27:13
updated: 2017/07/11 10:27:13
categories: emacs,dynamic-module
tags: 
---


<p>
The goal of this post is to be able to solve equations like this one:
</p>

<p>
\[\left(\begin{array}{cccc}
 0.18& 0.60& 0.57& 0.96 \\
 0.41& 0.24& 0.99& 0.58 \\
 0.14& 0.30& 0.97& 0.66 \\
 0.51& 0.13& 0.19& 0.85 \end{array} \right ) 
\left ( \begin{array}{c} x_0 \\ x_1 \\ x_2 \\ x_3 \end{array} \right )
= \left ( \begin{array}{c} 1.0 \\ 2.0 \\ 3.0 \\ 4.0 \end{array} \right ) \]
</p>

<p>
The answer is <a href="https://www.gnu.org/software/gsl/doc/html/linalg.html#examples:">given</a> as
</p>

<p>
\[x = \left ( \begin{array}{c} -4.05205 \\ -12.6056 \\ 1.66091 \\ 8.69377 \end{array} \right ) \]
</p>

<p>
The syntax we want to use is shown below, and we want it to return a vector containing the solution:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((A [[0.18 0.60 0.57 0.96]
          [0.41 0.24 0.99 0.58]
          [0.14 0.30 0.97 0.66]
          [0.51 0.13 0.19 0.85]])
      (b [1.0 2.0 3.0 4.0]))
  (gsl-linalg-LU-solve A b))
</pre>
</div>

<p>
Rather than put all the code in here like I have for the past several posts, I started a git repo at <a href="https://github.com/jkitchin/emacs-modules">https://github.com/jkitchin/emacs-modules</a> that contains this code. 
</p>


<p>
The module for this post can be found here: <a href="https://github.com/jkitchin/emacs-modules/blob/master/gsl-linalg.c">https://github.com/jkitchin/emacs-modules/blob/master/gsl-linalg.c</a>. There are a few notable features in it. First, I started writing/collecting <a href="https://github.com/jkitchin/emacs-modules/blob/master/emacs-module-helpers.c">some helper functions</a> to make these modules simpler to write. For example, look how nice this looks to declare the functions and provide the feature.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">int</span> <span style="color: #006699;">emacs_module_init</span>(<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">emacs_runtime</span> *<span style="color: #BA36A5;">ert</span>)
{
  <span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span> = ert-&gt;get_environment(ert);
  
  DEFUN(<span style="color: #008000;">"gsl-linalg-LU-solve"</span>, Fgsl_linalg_LU_solve, 2, 2,
        <span style="color: #008000;">"(gsl-linalg-LU-solve A b).\n"</span> \
        <span style="color: #008000;">"Solve A x = b for x.\n"</span> \
        <span style="color: #008000;">"Returns a vector containing the solution x."</span>,
        <span style="color: #D0372D;">NULL</span>);
  provide(env, <span style="color: #008000;">"gsl-linalg"</span>);
  
  <span style="color: #0000FF;">return</span> 0;
}
</pre>
</div>

<p>
The DEFUN and provide function are defined in <a href="https://github.com/jkitchin/emacs-modules/blob/master/emacs-module-helpers.c">https://github.com/jkitchin/emacs-modules/blob/master/emacs-module-helpers.c</a>.
</p>

<p>
Within the module itself, we have to loop over the inputs to create the arrays that GSL wants to solve this problem. Second, after the solution is obtained, we have to build up a vector to return. The solution is in a gsl_vector, and we need to create an array of emacs_value elements containing each element of the gsl_vector as a float, and then create a vector to return to emacs. I use vectors here because it was easy to get the size of the b vector, which is also related to the size of the A matrix.
</p>

<p>
The repo has a Makefile in it, so we can build this module with:
</p>

<div class="org-src-container">
<pre class="src src-sh">make gsl-linalg.so
</pre>
</div>

<p>
Once it is compiled, we load it like this. In this post we are in the emacs-modules directory where the gsl-linalg.so library is, and it is not on my load-path, so I add it here.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path (expand-file-name <span style="color: #008000;">"."</span>))
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">gsl-linalg</span>)
</pre>
</div>

<pre class="example">
gsl-linalg

</pre>

<p>
Here is one function in the module:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(describe-function 'gsl-linalg-LU-solve)
</pre>
</div>

<pre class="example">
gsl-linalg-LU-solve is a Lisp function.

(gsl-linalg-LU-solve &amp;rest ARGS)

For more information check the manuals.

(gsl-linalg-LU-solve A b).
Solve A x = b for x.
Returns a vector containing the solution x.

</pre>

<p>
Now, we can solve linear equations like this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gsl-linalg-LU-solve
 [[0.18 0.60 0.57 0.96]
  [0.41 0.24 0.99 0.58]
  [0.14 0.30 0.97 0.66]
  [0.51 0.13 0.19 0.85]]
 [1.0 2.0 3.0 4.0])
</pre>
</div>

<pre class="example">
[-4.052050229573973 -12.605611395906903 1.6609116267088417 8.693766928795227]

</pre>


<p>
We have a limited ability to confirm this answer. I have written a function that uses blas for multiplication of 2d vectors. You can see from this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gsl-blas-dgemm [[0.18 0.60 0.57 0.96]
                 [0.41 0.24 0.99 0.58]
                 [0.14 0.30 0.97 0.66]
                 [0.51 0.13 0.19 0.85]]
                [[-4.052050229573973]
                 [-12.605611395906903]
                 [1.6609116267088417]
                 [8.693766928795227]])
</pre>
</div>

<pre class="example">
[[1.0] [1.9999999999999991] [2.9999999999999996] [4.0]]

</pre>

<p>
That within float that indeed \(A x = b\).
</p>

<p>
The main limitation of this module at the moment is that you have to use vectors; you cannot put in a list of numbers. It is possible to make it take lists and vectors, but for now I am leaving it at vectors. Also, it only produces solutions of float numbers (not integers).
</p>

<p>
The module does not handle 1d vectors well,, e.g. in gsl-linalg-LU-solve example, the right hand side is implied to be a column vector, and we don't have the array broadcasting features of Python yet. Those are doable things for some future day perhaps. For now I am happy to have figured out how to handle arrays!
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>