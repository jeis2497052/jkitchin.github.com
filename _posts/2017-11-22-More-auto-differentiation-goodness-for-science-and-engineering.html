---
title: More auto-differentiation goodness for science and engineering
date: 2017/11/22 15:52:26
updated: 2017/11/22 15:52:26
categories: python, autograd
tags: 
---


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org956965a">1. Showing mixed partial derivatives are equal</a></li>
<li><a href="#orgaaf190d">2. Root finding with jacobians</a></li>
<li><a href="#org236ff6a">3. Getting the pressure from a solid equation of state</a></li>
<li><a href="#org931a2dd">4. Deriving activity coefficients and demonstration of the Gibbs-Duhem relation</a></li>
<li><a href="#org8d2c2e8">5. Summary</a></li>
</ul>
</div>
</div>
<p>
In this post I continue my investigations in the use of auto-differentiation via autograd in scientific and mathematical programming. The main focus of today is using autograd to get derivatives that either have mathematical value, eg. accelerating root finding, or demonstrating mathematical rules, or scientific value, e.g. the derivative is related to a property, or illustrates some constraint.
</p>

<p>
All the code in this post relies on these imports:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad, jacobian
</pre>
</div>

<p>

</p>

<p>
In the following sections I explore some applications in calculus, root-finding, materials and thermodynamics.
</p>

<div id="outline-container-org956965a" class="outline-2">
<h2 id="org956965a"><span class="section-number-2">1</span> Showing mixed partial derivatives are equal</h2>
<div class="outline-text-2" id="text-1">
<p>
In calculus, we know that if we have a well-behaved function \(f(x, y)\), then it should be true that \(\frac{\partial^2f}{\partial x \partial y} = \frac{\partial^2f}{\partial y \partial y}\).
</p>

<p>
Here we use autograd to compute the mixed partial derivatives and show for 10 random points that this statement is true. This doesnt' prove it for all points, of course, but it is easy to prove for any point of interest.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgea827b3"><span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x, y):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> x * y**2

<span style="color: #BA36A5;">dfdx</span> = grad(f)
<span style="color: #BA36A5;">d2fdxdy</span> = grad(dfdx, 1)

<span style="color: #BA36A5;">dfdy</span> = grad(f, 1)
<span style="color: #BA36A5;">d2fdydx</span> = grad(dfdy)

<span style="color: #BA36A5;">x</span> = np.random.rand(10)
<span style="color: #BA36A5;">y</span> = np.random.rand(10)

<span style="color: #BA36A5;">T</span> = [d2fdxdy(x1, y1) == d2fdydx(x1, y1) <span style="color: #0000FF;">for</span> x1, y1 <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(x, y)]

<span style="color: #0000FF;">print</span>(np.<span style="color: #006FE0;">all</span>(T))
</pre>
</div>

<p>
True
</p>
</div>
</div>

<div id="outline-container-orgaaf190d" class="outline-2">
<h2 id="orgaaf190d"><span class="section-number-2">2</span> Root finding with jacobians</h2>
<div class="outline-text-2" id="text-2">
<p>
fsolve often works fine without access to derivatives. In this example from <a href="http://people.duke.edu/~ccc14/sta-663-2016/13_Optimization.html">here</a>, we solve a set of equations with two variables, and it takes 21 iterations to reach the solution.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgca85f5c"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.array([x[1] - 3*x[0]*(x[0]+1)*(x[0]-1),
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>.25*x[0]**2 + x[1]**2 - 1])


<span style="color: #BA36A5;">ans</span>, <span style="color: #BA36A5;">info</span>, <span style="color: #BA36A5;">flag</span>, <span style="color: #BA36A5;">msg</span> = fsolve(f, (0.5, 0.5), full_output=1)
<span style="color: #0000FF;">print</span>(ans)
<span style="color: #0000FF;">print</span>(info[<span style="color: #008000;">'nfev'</span>])
</pre>
</div>

<p>
[ 1.117  0.83 ]
21
</p>

<p>
If we add the jacobian, we get the same result with only 15 iterations, about 1/3 fewer iterations. If the iterations are expensive, this might save a lot of time. 
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="org653514c"><span style="color: #BA36A5;">df</span> = jacobian(f)
<span style="color: #BA36A5;">x0</span> = np.array([0.5, 0.5])

<span style="color: #BA36A5;">ans</span>, <span style="color: #BA36A5;">info</span>, <span style="color: #BA36A5;">flag</span>, <span style="color: #BA36A5;">msg</span>  = fsolve(f, x0, fprime=df, full_output=1)
<span style="color: #0000FF;">print</span>(ans)
<span style="color: #0000FF;">print</span>(info[<span style="color: #008000;">'nfev'</span>])
</pre>
</div>

<p>
[ 1.117  0.83 ]
15
</p>

<p>
There is a similar <a href="https://github.com/HIPS/autograd/blob/master/examples/rosenbrock.py">example</a> provided by autograd.
</p>
</div>
</div>

<div id="outline-container-org236ff6a" class="outline-2">
<h2 id="org236ff6a"><span class="section-number-2">3</span> Getting the pressure from a solid equation of state</h2>
<div class="outline-text-2" id="text-3">
<p>
In this <a href="http://kitchingroup.cheme.cmu.edu/blog/2013/02/18/Nonlinear-curve-fitting/">post</a> we described how to fit a solid equation of state to describe the energy of a solid under isotropic strain. Now, we can readily compute the pressure at a particular volume from the equation:
</p>

<p>
\(P = -\frac{dE}{dV}\)
</p>

<p>
We just need the derivative of this equation:
</p>

<p>
\(E = E_0+\frac{B_0 V}{B'_0}\left[\frac{(V_0/V)^{B'_0}}{B'_0-1}+1\right]-\frac{V_0 B_0}{B'_0-1}\)
</p>

<p>
or we use autograd to get it for us.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgcc7d2c8"><span style="color: #BA36A5;">E0</span>, <span style="color: #BA36A5;">B0</span>, <span style="color: #BA36A5;">BP</span>, <span style="color: #BA36A5;">V0</span> = -56.466,   0.49,    4.753,  16.573

<span style="color: #0000FF;">def</span> <span style="color: #006699;">Murnaghan</span>(vol):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">E</span> = E0 + B0 * vol / BP * (((V0 / vol)**BP) / (BP - 1.0) + 1.0) - V0 * B0 / (BP - 1.)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> E

<span style="color: #0000FF;">def</span> <span style="color: #006699;">P</span>(vol):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">dEdV</span> = grad(Murnaghan)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> -dEdV(vol) * 160.21773  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">in Gpa</span>

<span style="color: #0000FF;">print</span>(P(V0)) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Pressure at the minimum</span>
<span style="color: #0000FF;">print</span>(P(0.99 * V0))  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Compressed</span>
</pre>
</div>

<pre class="example">
4.44693531998e-15
0.808167684691

</pre>

<p>
So it takes positive pressure to compress the system, as expected, and at the minimum the pressure is equal to zero. Seems pretty clear autograd is better than deriving the required pressure derivative.
</p>
</div>
</div>

<div id="outline-container-org931a2dd" class="outline-2">
<h2 id="org931a2dd"><span class="section-number-2">4</span> Deriving activity coefficients and demonstration of the Gibbs-Duhem relation</h2>
<div class="outline-text-2" id="text-4">
<p>
Thermodynamics tells us that in a binary mixture the following is true:
</p>

<p>
\(0 = x_1 \frac{d \ln \gamma_1}{dx_1} + (1 - x_1 \frac{d \ln \gamma_2}{dx_1}\)
</p>

<p>
In other words, the activity coefficients of the two species can't be independent. 
</p>

<p>
Suppose we have the <a href="https://en.wikipedia.org/wiki/Margules_activity_model">Margules model</a> for the excess free energy:
</p>

<p>
\(G^{ex}/RT = n x_1 (1 - x_1) (A21 x_1 + A_{12} (1 - x_1)\)
</p>

<p>
where \(n = n_1 + n_2\), and \(x_1 = n1 / n\), and \(x_2 = n_2 / n\). 
</p>

<p>
From this expression, we know:
</p>

<p>
\(\ln \gamma_1 = \frac{\partial G_{ex}/RT}{\partial n_1}\)
</p>

<p>
and
</p>

<p>
\(\ln \gamma_2 = \frac{\partial G_{ex}/RT}{\partial n_2}\)
</p>

<p>
It is also true that (the Gibbs-Duhem equation):
</p>

<p>
\(0 = x_1 \frac{d \ln \gamma_1}{d n_1} + x_2 \frac{d \ln \gamma_2}{d n_1}\)
</p>

<p>
Here we will use autograd to get these derivatives, and demonstrate the Gibbs-Duhem eqn holds for this excess Gibbs energy model.
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgfb33345"><span style="color: #BA36A5;">A12</span>, <span style="color: #BA36A5;">A21</span> = 2.04, 1.5461  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Acetone/water https://en.wikipedia.org/wiki/Margules_activity_model</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">GexRT</span>(n1, n2):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">n</span> = n1 + n2
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">x1</span> = n1 / n
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">x2</span> = n2 / n
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> n * x1 * x2 * (A21 * x1 + A12 * x2)

<span style="color: #BA36A5;">lngamma1</span> = grad(GexRT)     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">dGex/dn1</span>
<span style="color: #BA36A5;">lngamma2</span> = grad(GexRT, 1)  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">dGex/dn2</span>

<span style="color: #BA36A5;">n1</span>, <span style="color: #BA36A5;">n2</span> = 1.0, 2.0
<span style="color: #BA36A5;">n</span> = n1 + n2
<span style="color: #BA36A5;">x1</span> = n1 / n
<span style="color: #BA36A5;">x2</span> = n2 / n

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Evaluate the activity coefficients</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'AD:         '</span>,lngamma1(n1, n2), lngamma2(n1, n2))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Compare that to these analytically derived activity coefficients</span>
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Analytical: '</span>, (A12 + 2 * (A21 - A12) * x1) * x2**2, (A21 + 2 * (A12 - A21) * x2) * x1**2)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Demonstration of the Gibbs-Duhem rule</span>
<span style="color: #BA36A5;">dg1</span> = grad(lngamma1)
<span style="color: #BA36A5;">dg2</span> = grad(lngamma2)

<span style="color: #BA36A5;">n</span> = 1.0 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Choose a basis number of moles</span>
<span style="color: #BA36A5;">x1</span> = np.linspace(0, 1)
<span style="color: #BA36A5;">x2</span> = 1 - x1
<span style="color: #BA36A5;">n1</span> = n * x1
<span style="color: #BA36A5;">n2</span> = n - n1

<span style="color: #BA36A5;">GD</span> = [_x1 * dg1(_n1, _n2) + _x2 * dg2(_n1, _n2)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> <span style="color: #0000FF;">for</span> _x1, _x2, _n1, _n2 <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(x1, x2, n1, n2)]

<span style="color: #0000FF;">print</span>(np.allclose(GD, np.zeros(<span style="color: #006FE0;">len</span>(GD))))
</pre>
</div>

<pre class="example">
('AD:         ', 0.76032592592592585, 0.24495925925925932)
('Analytical: ', 0.760325925925926, 0.24495925925925924)
True

</pre>

<p>
That is pretty compelling. The autograd derivatives are much easier to code than the analytical solutions (which also had to be derived). You can also see that the Gibbs-Duhem equation is satisfied for this model, at least with a reasonable tolerance for the points we evaluated it at. 
</p>
</div>
</div>

<div id="outline-container-org8d2c2e8" class="outline-2">
<h2 id="org8d2c2e8"><span class="section-number-2">5</span> Summary</h2>
<div class="outline-text-2" id="text-5">
<p>
Today we examined four ways to use autograd in scientific or mathematical programs to replace the need to derive derivatives by hand. The main requirements for this to work are that you use the autograd.numpy module, and only the functions in it that are supported. It is possible to add your own functions (described in the <a href="https://github.com/HIPS/autograd/blob/master/docs/tutorial.md#extend-autograd-by-defining-your-own-primitives">tutorial</a>) if needed. It seems like there are a lot of opportunities for scientific programming for autograd.
</p>
</div>
</div>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/11/22/More-auto-differentiation-goodness-for-science-and-engineering.org">org-mode source</a></p>
<p>Org-mode version = 9.1.2</p>